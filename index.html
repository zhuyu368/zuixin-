<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>梦角爱人 - 私密聊天</title>
<style>
/* 主题色变量 - 完全保留第二个文件的所有CSS */
:root {
  --bg-main: #bfbfbf;
  --bg-panel: rgba(229, 229, 229, 0.85);
  --msg-self: #dedede;
  --msg-other: #f2f2f2;
  --text: #5c5c5c;
  --accent: #8a7f8d;
  --accent-light: #a99cad;
  --accent-gray: #9e9e9e;
  --accent-gray-light: #bdbdbd;
  --online: #4caf50;
  --busy: #ff9800;
  --dr: #2196f3;
  --cr: #9c27b0;
  --nearby: #ff5722;
  --mood-happy: #ffcc00;
  --mood-normal: #4caf50;
  --mood-sad: #9c27b0;
  --mood-angry: #f44336;
  --quote-bg: rgba(138, 127, 141, 0.1);
  --call-bg: rgba(33, 150, 243, 0.1);
  --call-text: #2196f3;
  --video-bg: rgba(156, 39, 176, 0.1);
  --video-text: #9c27b0;
  --tarot-bg: rgba(156, 39, 176, 0.1);
  --tarot-text: #7b1fa2;
}

/* ===== 新增：夜间模式颜色变量 ===== */
.night-mode {
  --bg-main: #1a1a1a;
  --bg-panel: rgba(30, 30, 30, 0.95);
  --msg-self: #2d2d2d;
  --msg-other: #3a3a3a;
  --text: #e0e0e0;
  --accent: #b3a6b5;
  --accent-light: #c4b7c7;
  --accent-gray: #6a6a6a;
  --accent-gray-light: #8a8a8a;
  --online: #2e7d32;
  --busy: #f57c00;
  --dr: #1976d2;
  --cr: #7b1fa2;
  --nearby: #d84315;
  --quote-bg: rgba(180, 170, 190, 0.15);
  --call-bg: rgba(33, 150, 243, 0.2);
  --call-text: #64b5f6;
  --video-bg: rgba(156, 39, 176, 0.2);
  --video-text: #ba68c8;
  --tarot-bg: rgba(156, 39, 176, 0.2);
  --tarot-text: #ce93d8;
}
/* ================================ */

/* 基础样式 - 完全保留第二个文件的所有CSS */
body {
  margin: 0;
  height: 100vh;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: var(--bg-main);
  background-image: radial-gradient(#ffffff55 2px, transparent 2px);
  background-size: 30px 30px;
  display: flex;
  justify-content: center;
  align-items: center;
  color: var(--text);
  overflow: hidden;
  transition: background 0.5s ease;
}

/* 背景图片容器 */
.background-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: -1;
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  transition: opacity 0.5s ease;
}

/* 主容器 */
.container {
  width: 100%;
  max-width: 900px;
  height: 90vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 15px;
  padding: 15px;
  box-sizing: border-box;
  position: relative;
}

/* 聊天头部区域 */
.chat-header {
  width: 100%;
  max-width: 800px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 0;
}

/* 用户信息区域 */
/* 用户信息区域 - 重新排列：昵称在上，头像在下 */
.user-info {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 75px;
  cursor: pointer;
  position: relative;
  /* 增加整体下移距离 */
  margin-top: 15px;
}

/* 昵称 - 放到头像上方 */
.user-info .nickname {
  order: 1;           /* 排在第1位 */
  margin-bottom: 6px; /* 与头像的间距 */
  margin-top: 0;      /* 移除原来的上边距 */
}

/* 头像 - 放到昵称下方 */
.user-info .avatar {
  order: 2;           /* 排在第2位 */
  margin-bottom: 3px;
}

/* 状态指示器 - 位置调整 */
.user-info .status-indicator {
  order: 3;           /* 排在第3位 */
  top: 38px;          /* 原先是0，现在下移到头像旁边 */
  right: 10px;
}

/* 状态文字 - 放到头像下方 */
.user-info .status-text {
  order: 4;           /* 排在第4位 */
  margin-top: 2px;
}

/* 心情指数 - 放到状态文字下方 */
.user-info .mood-percentage {
  order: 5;           /* 排在第5位 */
  margin-top: 2px;
}

/* 对方状态指示器特殊调整 - 下移更多 */
#otherUserInfo .status-indicator {
  top: 42px;          /* 对方状态圆点下移更多 */
}

/* 自己状态指示器特殊调整 - 下移更多 */
#selfUserInfo .status-indicator {
  top: 42px;          /* 自己状态圆点下移更多 */
}

/* 修改：头像样式改为纯白色圆形，无文字无边框 */
.avatar {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  overflow: hidden;
  margin-bottom: 3px;
  background-color: white;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* 修改：确保头像内容为空 */
.avatar span {
  display: none;
}

.avatar img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

/* 心情指数 */
.mood-percentage {
  font-size: 0.65rem;
  color: var(--text);
  margin-top: 2px;
  text-align: center;
  height: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 500;
}

/* 状态指示器 */
.status-indicator {
  position: absolute;
  top: 0;
  right: 10px;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  border: 2px solid var(--bg-panel);
  z-index: 2;
}

.status-indicator.online {
  background-color: var(--online);
}

.status-indicator.busy {
  background-color: var(--busy);
}

.status-indicator.dr {
  background-color: var(--dr);
}

.status-indicator.cr {
  background-color: var(--cr);
}

.status-indicator.nearby {
  background-color: var(--nearby);
}

/* 状态文字 */
.status-text {
  font-size: 0.65rem;
  color: var(--text);
  opacity: 0.8;
  margin-top: 2px;
  text-align: center;
  height: 14px;
}

/* 昵称 - 淡粉色INS玻璃气泡 */
.nickname {
  font-size: 0.75rem;
  text-align: center;
  max-width: 100%;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: #b27c7c;
  margin-top: 8px;
  padding: 6px 18px;
  /* 淡粉色玻璃 — INS风 */
  background: rgba(255, 220, 225, 0.2);
  backdrop-filter: blur(12px);
  border-radius: 40px;
  border: 0.5px solid rgba(255, 200, 200, 0.5);
  font-weight: 500;
  letter-spacing: 0.5px;
  box-shadow: 0 6px 16px rgba(255, 180, 190, 0.15), inset 0 1px 4px rgba(255, 255, 255, 0.8);
  animation: floatNickname 3s ease-in-out infinite;
  transition: all 0.3s ease;
}

/* 夜间模式下昵称颜色微调 */
.night-mode .nickname {
  color: #dba5a5;
  background: rgba(80, 50, 60, 0.4);
  border-color: rgba(180, 120, 130, 0.5);
}

/* 对方昵称 - 漂浮更高、更慢（淡粉色） */
#otherNickname.nickname {
  animation: floatNicknameOther 4s ease-in-out infinite;
  background: rgba(255, 220, 230, 0.2);
}

/* 自己昵称 - 漂浮更轻快（淡粉色） */
#selfNickname.nickname {
  animation: floatNicknameSelf 2.8s ease-in-out infinite;
  background: rgba(255, 220, 230, 0.2);
}

/* 昵称漂浮动画 - 基础 */
@keyframes floatNickname {
  0% {
    transform: translateY(0px);
    box-shadow: 0 6px 16px rgba(255, 180, 190, 0.15), inset 0 1px 4px rgba(255, 255, 255, 0.8);
  }
  50% {
    transform: translateY(-5px);
    box-shadow: 0 14px 22px rgba(255, 160, 170, 0.25), inset 0 1px 6px rgba(255, 255, 255, 0.9);
    background: rgba(255, 225, 230, 0.3);
  }
  100% {
    transform: translateY(0px);
    box-shadow: 0 6px 16px rgba(255, 180, 190, 0.15), inset 0 1px 4px rgba(255, 255, 255, 0.8);
  }
}

/* 昵称漂浮动画 - 对方（更高） */
@keyframes floatNicknameOther {
  0% {
    transform: translateY(0px);
    box-shadow: 0 6px 16px rgba(255, 180, 190, 0.15), inset 0 1px 4px rgba(255, 255, 255, 0.8);
  }
  50% {
    transform: translateY(-10px);
    box-shadow: 0 16px 26px rgba(255, 160, 170, 0.28), inset 0 1px 6px rgba(255, 255, 255, 0.9);
    background: rgba(255, 220, 230, 0.35);
  }
  100% {
    transform: translateY(0px);
    box-shadow: 0 6px 16px rgba(255, 180, 190, 0.15), inset 0 1px 4px rgba(255, 255, 255, 0.8);
  }
}

/* 昵称漂浮动画 - 自己（轻快） */
@keyframes floatNicknameSelf {
  0% {
    transform: translateY(0px);
    box-shadow: 0 6px 16px rgba(255, 180, 190, 0.15), inset 0 1px 4px rgba(255, 255, 255, 0.8);
  }
  50% {
    transform: translateY(-7px);
    box-shadow: 0 14px 22px rgba(255, 160, 170, 0.26), inset 0 1px 6px rgba(255, 255, 255, 0.9);
    background: rgba(255, 225, 235, 0.32);
  }
  100% {
    transform: translateY(0px);
    box-shadow: 0 6px 16px rgba(255, 180, 190, 0.15), inset 0 1px 4px rgba(255, 255, 255, 0.8);
  }
}

/* 悬停时 - 浮动暂停，粉色加深 */
.nickname:hover {
  animation: none;
  transform: translateY(-8px) scale(1.05);
  background: rgba(255, 210, 220, 0.45);
  border-color: rgba(255, 180, 190, 0.7);
  box-shadow: 0 18px 28px rgba(255, 150, 160, 0.3), inset 0 1px 6px rgba(255, 255, 255, 0.9);
  color: #a57272;
}

/* 对方昵称悬停 */
#otherNickname.nickname:hover {
  background: rgba(255, 200, 215, 0.5);
  border-color: rgba(255, 170, 180, 0.75);
  color: #a57272;
}

/* 自己昵称悬停 */
#selfNickname.nickname:hover {
  background: rgba(255, 200, 215, 0.5);
  border-color: rgba(255, 170, 180, 0.75);
  color: #a57272;
}

/* 悬停时 - 浮动暂停，更明显反馈 */
.nickname:hover {
  animation: none;
  transform: translateY(-10px) scale(1.05);
  background: #ffd9e0;
  border-color: #ffb0c0;
  box-shadow: 0 20px 30px rgba(249, 200, 210, 0.7);
  color: #522e36;
}

/* 对方昵称悬停 */
#otherNickname.nickname:hover {
  background: #ffd0d9;
  border-color: #ff99aa;
  color: #4a2a30;
}

/* 自己昵称悬停 */
#selfNickname.nickname:hover {
  background: #ffd5dd;
  border-color: #ffa5b5;
  color: #4a2a30;
}

/* 聊天标题区域 */
.chat-title-area {
  text-align: center;
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-width: 0;
  padding: 0 5px;
}

.chat-title-area h1 {
  margin: 0;
  font-weight: 300;
  font-size: 1.6rem;
  color: var(--accent);
  letter-spacing: 1px;
  line-height: 1.2;
}

/* 副标题 - 淡粉色INS玻璃气泡（与恋爱天数一致） */
.chat-subtitle {
  margin: 8px 0 0;
  font-size: 0.7rem;
  color: #b27c7c;
  max-width: 100%;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  padding: 6px 18px;
  /* 淡粉色玻璃 — INS风 */
  background: rgba(255, 220, 225, 0.2);
  backdrop-filter: blur(10px);
  border-radius: 40px;
  border: 0.5px solid rgba(255, 200, 200, 0.5);
  box-shadow: 0 6px 16px rgba(255, 180, 190, 0.15), inset 0 1px 4px rgba(255, 255, 255, 0.8);
  font-weight: 400;
  letter-spacing: 0.5px;
  animation: floatSubtitle 4s ease-in-out infinite;
  transition: all 0.3s ease;
  display: inline-block;  /* 让气泡根据内容自适应宽度 */
}

/* 夜间模式副标题 */
.night-mode .chat-subtitle {
  color: #dba5a5;
  background: rgba(80, 50, 60, 0.4);
  border-color: rgba(180, 120, 130, 0.5);
}

/* 副标题专属漂浮动画 - 更轻盈 */
@keyframes floatSubtitle {
  0% {
    transform: translateY(0px);
    box-shadow: 0 6px 16px rgba(255, 180, 190, 0.15), inset 0 1px 4px rgba(255, 255, 255, 0.8);
  }
  50% {
    transform: translateY(-4px);
    box-shadow: 0 12px 22px rgba(255, 160, 170, 0.25), inset 0 1px 6px rgba(255, 255, 255, 0.9);
    background: rgba(255, 225, 230, 0.3);
  }
  100% {
    transform: translateY(0px);
    box-shadow: 0 6px 16px rgba(255, 180, 190, 0.15), inset 0 1px 4px rgba(255, 255, 255, 0.8);
  }
}

/* 悬停时 - 浮动暂停，粉色加深 */
.chat-subtitle:hover {
  animation: none;
  transform: translateY(-4px) scale(1.02);
  background: rgba(255, 210, 220, 0.4);
  border-color: rgba(255, 180, 190, 0.7);
  box-shadow: 0 14px 24px rgba(255, 150, 160, 0.3), inset 0 1px 6px rgba(255, 255, 255, 0.9);
  color: #a57272;
}

/* 恋爱天数 - 淡粉色INS玻璃气泡 */
.love-days {
  margin-top: 5px;
  font-size: 0.7rem;
  color: #b27c7c;
  display: flex;
  align-items: center;
  gap: 3px;
  cursor: pointer;
  padding: 8px 20px;
  border-radius: 50px;
  /* 淡粉色玻璃 — INS风 */
  background: rgba(255, 220, 225, 0.25);
  backdrop-filter: blur(10px);
  border: 0.5px solid rgba(255, 200, 200, 0.5);
  box-shadow: 0 6px 16px rgba(255, 180, 190, 0.2), inset 0 1px 4px rgba(255, 255, 255, 0.8);
  white-space: nowrap;
  letter-spacing: 0.5px;
  font-weight: 500;
  animation: floatLove 4s ease-in-out infinite;
  transition: all 0.3s ease;
  position: relative;
}

/* 夜间模式恋爱天数 */
.night-mode .love-days {
  color: #dba5a5;
  background: rgba(80, 50, 60, 0.45);
  border-color: rgba(180, 120, 130, 0.5);
}

@keyframes floatLove {
  0% {
    transform: translateY(0px) scale(1);
    box-shadow: 0 6px 16px rgba(255, 180, 190, 0.15), inset 0 1px 4px rgba(255, 255, 255, 0.8);
  }
  50% {
    transform: translateY(-6px) scale(1.02);
    box-shadow: 0 14px 24px rgba(255, 160, 170, 0.25), inset 0 1px 6px rgba(255, 255, 255, 0.9);
    background: rgba(255, 225, 230, 0.3);
  }
  100% {
    transform: translateY(0px) scale(1);
    box-shadow: 0 6px 16px rgba(255, 180, 190, 0.15), inset 0 1px 4px rgba(255, 255, 255, 0.8);
  }
}

.love-days:hover {
  animation: none;
  transform: translateY(-6px) scale(1.05);
  background: rgba(255, 210, 220, 0.4);
  border-color: rgba(255, 180, 190, 0.7);
  box-shadow: 0 16px 28px rgba(255, 150, 160, 0.3), inset 0 1px 6px rgba(255, 255, 255, 0.9);
}

.love-days i {
  font-size: 0.85rem;
  color: #c28b8b;
  transition: all 0.3s ease;
}

.love-days:hover i {
  transform: scale(1.2);
  color: #b47a7a;
}

#loveDaysCount {
  color: #9d6b6b;
  font-weight: 500;
}

/* ===== 新增：夜间模式切换按钮 ===== */
.theme-toggle {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  background: var(--accent);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 4px 12px rgba(138, 127, 141, 0.3);
  flex-shrink: 0;
}

.theme-toggle:hover {
  background: var(--accent-light);
  transform: rotate(30deg);
}

.theme-toggle i {
  color: white;
  font-size: 1.1rem;
}
/* ================================ */

/* 设置齿轮按钮 */
.settings-toggle {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  background: var(--accent);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 4px 12px rgba(138, 127, 141, 0.3);
  flex-shrink: 0;
}

.settings-toggle:hover {
  background: var(--accent-light);
  transform: rotate(30deg);
}

.settings-toggle i {
  color: white;
  font-size: 1.1rem;
}

/* 聊天区域 */
.chat-section {
  width: 100%;
  height: calc(100% - 120px);
  max-width: 800px;
  display: flex;
  flex-direction: column;
}

.chat-container {
  width: 100%;
  height: 100%;
  background: transparent;  
  backdrop-filter: none;    
  border-radius: 18px;
  padding: 15px;
  display: flex;
  flex-direction: column;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
}

/* 聊天消息区域 */
.messages-area {
  flex: 1;
  overflow-y: auto;
  padding: 8px 4px;
  display: flex;
  flex-direction: column;
  gap: 6px;
  margin-bottom: 12px;
}

/* 消息容器 - 包含头像和消息 */
.message-container {
  display: flex;
  align-items: flex-start;
  gap: 8px;
  max-width: 100%;
}

.message-container.self {
  flex-direction: row-reverse;
}

.message-avatar {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  overflow: hidden;
  flex-shrink: 0;
  border: 1px solid rgba(92, 92, 92, 0.2);
}

.message-avatar img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.message-content {
  max-width: 70%;
  display: flex;
  flex-direction: column;
  position: relative;
}

.message-container.self .message-content {
  align-items: flex-end;
}

.message-container.other .message-content {
  align-items: flex-start;
}

/* 消息样式 */
.message {
  max-width: 100%;
  padding: 8px 12px;
  border-radius: 16px;
  line-height: 1.4;
  word-wrap: break-word;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
  font-size: 0.9rem;
  position: relative;
  cursor: pointer;
  transition: background-color 0.2s;
}

.message:hover {
  opacity: 0.95;
}

.message.self {
  background: var(--msg-self);
  border-bottom-right-radius: 4px;
}

.message.other {
  background: var(--msg-other);
  border-bottom-left-radius: 4px;
}

.message-time {
  font-size: 0.65rem;
  opacity: 0.6;
  margin-top: 4px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 6px;
}

/* 修改：消息操作菜单样式优化 */
.message-actions {
  position: absolute;
  top: -40px;
  background: white;
  border-radius: 8px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
  display: none;
  flex-direction: row;
  z-index: 10;
  overflow: hidden;
  padding: 2px;
}

.message-container.self .message-actions {
  right: 0;
}

.message-container.other .message-actions {
  left: 0;
}

/* 修改：操作按钮变大并使用灰色主题 */
.message-action-btn {
  padding: 8px 16px;
  border: none;
  background: transparent;
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.2s;
  white-space: nowrap;
  color: var(--accent-gray);
  border-radius: 6px;
  margin: 2px;
}

.message-action-btn:hover {
  background: var(--accent-gray-light);
  color: white;
  transform: translateY(-1px);
}

/* 所有操作按钮统一使用灰色主题 */
.message-action-btn.delete {
  color: var(--accent-gray);
}

.message-action-btn.quote {
  color: var(--accent-gray);
}

.message-action-btn.recall {
  color: var(--accent-gray);
}

/* 消息状态 */
.message-status {
  display: flex;
  align-items: center;
  gap: 2px;
  font-size: 0.65rem;
}

.status-check {
  font-size: 0.8rem;
}

.status-check.single {
  color: #888;
}

.status-check.double {
  color: var(--accent);
}

/* 已读不回提示 */
.read-no-reply {
  color: var(--busy);
  font-size: 0.65rem;
  margin-top: 2px;
  display: flex;
  align-items: center;
  gap: 3px;
}

/* 引用消息样式 */
.quoted-message {
  background: var(--quote-bg);
  padding: 6px 8px;
  border-radius: 8px;
  margin-bottom: 6px;
  border-left: 3px solid var(--accent);
  font-size: 0.8rem;
  opacity: 0.9;
  max-width: 100%;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  cursor: pointer;
}

.quoted-message img {
  max-height: 20px;
  border-radius: 4px;
  vertical-align: middle;
  margin-right: 4px;
}

/* 对方正在输入动画 */
.typing-indicator {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 6px 12px;
  background: var(--msg-other);
  border-radius: 16px;
  align-self: flex-start;
  max-width: 130px;
  margin-bottom: 4px;
  opacity: 0;
  transition: opacity 0.3s;
  margin-left: 40px;
  font-size: 0.8rem;
}

.typing-indicator.active {
  opacity: 1;
}

.typing-indicator .dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background-color: var(--text);
  opacity: 0.4;
  animation: typingAnimation 1.5s infinite ease-in-out;
}

.typing-indicator .dot:nth-child(1) {
  animation-delay: 0s;
}

.typing-indicator .dot:nth-child(2) {
  animation-delay: 0.2s;
}

.typing-indicator .dot:nth-child(3) {
  animation-delay: 0.4s;
}

@keyframes typingAnimation {
  0%, 60%, 100% {
    transform: translateY(0);
    opacity: 0.4;
  }
  30% {
    transform: translateY(-4px);
    opacity: 0.8;
  }
}

/* 输入区域 */
.input-area {
  display: flex;
  gap: 8px;
  align-items: flex-end;
  position: relative;
}

/* 修改：缩短输入框 */
.message-input {
  flex: 1;
  min-width: 200px;
  padding: 12px 16px;
  border: none;
  border-radius: 22px;
  background: rgba(255, 255, 255, 0.7);
  font-size: 0.9rem;
  color: var(--text);
  outline: none;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
}

.night-mode .message-input {
  background: rgba(50, 50, 50, 0.8);
  color: #e0e0e0;
}

.message-input:focus {
  background: rgba(255, 255, 255, 0.9);
}

/* 输入区域按钮容器 */

.input-area-buttons {
  display: flex;
  gap: 6px;           
  align-items: center;
  flex-wrap: nowrap;   
  width: 100%;
}

/* 修改：将发送按钮改为灰色主题色 */
.send-button {
  padding: 12px 20px;
  border: none;
  border-radius: 22px;
  background: var(--accent-gray);
  color: white;
  font-size: 0.9rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 4px 10px rgba(158, 158, 158, 0.3);
  white-space: nowrap;
}

.send-button:hover {
  background: var(--accent-gray-light);
  transform: translateY(-2px);
}

.send-button:active {
  transform: translateY(0);
}

/* 修改：将"继续"按钮改为"..."图案的灰色按钮 */
.continue-button {
  width: 44px;
  height: 44px;
  padding: 0;
  border: none;
  border-radius: 22px;
  background: var(--accent-gray);
  color: white;
  font-size: 1.5rem;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 4px 10px rgba(158, 158, 158, 0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

.continue-button:hover {
  background: var(--accent-gray-light);
  transform: translateY(-2px);
}

/* 修改：将图片上传按钮改为灰色主题色 */
.upload-image-button {
  width: 44px;
  height: 44px;
  border-radius: 22px;
  background: var(--accent-gray);
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 4px 10px rgba(158, 158, 158, 0.3);
  flex-shrink: 0;
}

.upload-image-button:hover {
  background: var(--accent-gray-light);
  transform: translateY(-2px);
}

.upload-image-button i {
  font-size: 1.2rem;
}

/* 设置面板 */
.settings-panel {
  position: fixed;
  top: 0;
  right: -450px;
  width: 420px;
  height: 100vh;
  background: var(--bg-panel);
  backdrop-filter: blur(12px);
  box-shadow: -5px 0 25px rgba(0, 0, 0, 0.15);
  transition: right 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  z-index: 1000;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.settings-panel.active {
  right: 0;
}

.settings-header {
  padding: 20px;
  border-bottom: 1px solid rgba(92, 92, 92, 0.1);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.settings-header h2 {
  margin: 0;
  font-weight: 400;
  color: var(--accent);
  font-size: 1.6rem;
}

.close-settings {
  background: none;
  border: none;
  font-size: 1.6rem;
  color: var(--text);
  cursor: pointer;
  opacity: 0.7;
  transition: opacity 0.2s;
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
}

.close-settings:hover {
  opacity: 1;
  background: rgba(92, 92, 92, 0.1);
}

/* 设置内容区域 */
.settings-content {
  flex: 1;
  overflow-y: auto;
  padding: 0 20px 20px;
}

.settings-tabs {
  display: flex;
  border-bottom: 1px solid rgba(92, 92, 92, 0.1);
  margin-bottom: 20px;
  flex-wrap: wrap;
}

.tab-button {
  flex: 1;
  padding: 12px;
  background: none;
  border: none;
  border-bottom: 3px solid transparent;
  font-size: 0.9rem;
  color: var(--text);
  cursor: pointer;
  transition: all 0.2s;
  text-align: center;
  min-width: 80px;
}

.tab-button.active {
  border-bottom-color: var(--accent);
  color: var(--accent);
  font-weight: 500;
}

.tab-content {
  display: none;
}

.tab-content.active {
  display: block;
}

/* 表情包库区域 */
.sticker-library h3,
.phrases-library h3,
.ratio-library h3,
.appearance-library h3,
.communication-library h3,
.background-library h3,
.tarot-library h3,
.music-library h3 {
  margin-top: 0;
  margin-bottom: 12px;
  font-weight: 400;
  color: var(--accent);
  font-size: 1.2rem;
}

.sticker-library p,
.phrases-library p,
.ratio-library p,
.appearance-library p,
.communication-library p,
.background-library p,
.tarot-library p,
.music-library p {
  margin: 0 0 16px;
  font-size: 0.85rem;
  opacity: 0.8;
  line-height: 1.4;
}

.sticker-preview {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 10px;
  margin-bottom: 20px;
  max-height: 250px;
  overflow-y: auto;
  padding: 4px;
}

.sticker-item {
  width: 100%;
  aspect-ratio: 1;
  border-radius: 8px;
  overflow: hidden;
  background: rgba(255, 255, 255, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  border: 2px dashed rgba(92, 92, 92, 0.2);
  position: relative;
}

.sticker-item img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.sticker-placeholder {
  font-size: 1.5rem;
  color: rgba(92, 92, 92, 0.3);
}

.delete-sticker {
  position: absolute;
  top: 4px;
  right: 4px;
  background: rgba(0, 0, 0, 0.6);
  color: white;
  border: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.8rem;
  cursor: pointer;
  opacity: 0;
  transition: opacity 0.2s;
}

.sticker-item:hover .delete-sticker {
  opacity: 1;
}

/* 修改：将所有设置按钮改为灰色主题色 */
.add-sticker-btn,
.save-phrases-btn,
.communication-btn,
.save-background-btn,
.save-tarot-btn,
.format-btn,
.background-upload-btn,
.remove-background-btn,
.modal-btn.primary,
#saveMusicSettingsBtn {
  display: block;
  width: 100%;
  padding: 12px;
  border: none;
  border-radius: 10px;
  background: var(--accent-gray);
  color: white;
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.2s ease;
  margin-bottom: 12px;
}

.add-sticker-btn:hover,
.save-phrases-btn:hover,
.communication-btn:hover,
.save-background-btn:hover,
.save-tarot-btn:hover,
.format-btn:hover,
.background-upload-btn:hover,
.remove-background-btn:hover,
.modal-btn.primary:hover,
#saveMusicSettingsBtn:hover {
  background: var(--accent-gray-light);
}

/* 字卡管理区域 */
.phrases-textarea {
  width: 100%;
  height: 180px;
  padding: 12px;
  border: 1px solid rgba(92, 92, 92, 0.2);
  border-radius: 10px;
  background: rgba(255, 255, 255, 0.7);
  font-size: 0.85rem;
  line-height: 1.4;
  resize: vertical;
  margin-bottom: 12px;
  box-sizing: border-box;
}

.phrases-textarea:focus {
  outline: none;
  border-color: var(--accent);
  background: rgba(255, 255, 255, 0.9);
}

.phrases-info {
  display: flex;
  justify-content: space-between;
  margin-bottom: 16px;
  font-size: 0.85rem;
  color: rgba(92, 92, 92, 0.7);
}

/* 比例设置区域 */
.ratio-controls {
  background: rgba(255, 255, 255, 0.5);
  border-radius: 10px;
  padding: 16px;
  margin-bottom: 20px;
}

.ratio-item {
  margin-bottom: 16px;
}

.ratio-item:last-child {
  margin-bottom: 0;
}

.ratio-label {
  display: flex;
  justify-content: space-between;
  margin-bottom: 6px;
  font-size: 0.85rem;
}

.ratio-slider {
  width: 100%;
  height: 5px;
  -webkit-appearance: none;
  appearance: none;
  background: rgba(92, 92, 92, 0.2);
  border-radius: 3px;
  outline: none;
}

.ratio-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: var(--accent);
  cursor: pointer;
  border: 2px solid white;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.ratio-slider::-moz-range-thumb {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: var(--accent);
  cursor: pointer;
  border: 2px solid white;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.ratio-value {
  font-weight: 500;
  color: var(--accent);
}

.max-count-control,
.auto-send-controls {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-top: 20px;
  padding-top: 16px;
  border-top: 1px solid rgba(92, 92, 92, 0.1);
}

.max-count-label,
.auto-send-label {
  font-size: 0.9rem;
}

.max-count-select,
.auto-send-select {
  padding: 6px 12px;
  border-radius: 8px;
  border: 1px solid rgba(92, 92, 92, 0.3);
  background: rgba(255, 255, 255, 0.7);
  color: var(--text);
  font-size: 0.85rem;
  outline: none;
  width: 70px;
}

/* 外观设置区域 */
.appearance-controls {
  background: rgba(255, 255, 255, 0.5);
  border-radius: 10px;
  padding: 16px;
  margin-bottom: 20px;
}

.appearance-item {
  margin-bottom: 16px;
}

.appearance-item:last-child {
  margin-bottom: 0;
}

.appearance-label {
  display: block;
  margin-bottom: 6px;
  font-size: 0.85rem;
  color: var(--text);
}

.appearance-input {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid rgba(92, 92, 92, 0.3);
  border-radius: 8px;
  background: rgba(255, 255, 255, 0.7);
  font-size: 0.85rem;
  color: var(--text);
  outline: none;
  box-sizing: border-box;
}

.appearance-input:focus {
  border-color: var(--accent);
  background: rgba(255, 255, 255, 0.9);
}

.date-inputs {
  display: flex;
  gap: 8px;
  align-items: center;
}

.date-input {
  flex: 1;
  padding: 8px 12px;
  border: 1px solid rgba(92, 92, 92, 0.3);
  border-radius: 8px;
  background: rgba(255, 255, 255, 0.7);
  font-size: 0.85rem;
  color: var(--text);
  outline: none;
}

.date-input:focus {
  border-color: var(--accent);
}

/* 通信设置区域 */
.communication-controls {
  background: rgba(255, 255, 255, 0.5);
  border-radius: 10px;
  padding: 16px;
  margin-bottom: 20px;
}

.communication-item {
  margin-bottom: 20px;
}

.communication-item:last-child {
  margin-bottom: 0;
}

.communication-label {
  display: block;
  margin-bottom: 8px;
  font-size: 0.9rem;
  font-weight: 500;
  color: var(--text);
}

.communication-buttons {
  display: flex;
  gap: 10px;
  margin-top: 12px;
}

/* 修改：通话和视频按钮改为ins黑白色 */
.call-button, .video-button {
  flex: 1;
  padding: 12px;
  border: none;
  border-radius: 10px;
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  background: #000000;
  color: #ffffff;
  border: 2px solid #000000;
  font-weight: 500;
}

.call-button:hover, .video-button:hover {
  background: #333333;
  color: #ffffff;
  border-color: #333333;
  transform: translateY(-2px);
}

.communication-stats {
  background: rgba(255, 255, 255, 0.7);
  border-radius: 8px;
  padding: 12px;
  margin-top: 16px;
  font-size: 0.85rem;
}

.communication-stats p {
  margin: 6px 0;
}

/* 新增：主动呼叫设置区域 */
.active-call-controls {
  background: rgba(255, 255, 255, 0.7);
  border-radius: 10px;
  padding: 16px;
  margin-bottom: 20px;
  border-left: 4px solid var(--accent);
}

.active-call-item {
  margin-bottom: 16px;
}

.active-call-item:last-child {
  margin-bottom: 0;
}

.active-call-slider {
  width: 100%;
  height: 6px;
  -webkit-appearance: none;
  appearance: none;
  background: linear-gradient(to right, #ccc, var(--accent));
  border-radius: 3px;
  outline: none;
  margin-top: 8px;
}

.active-call-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: var(--accent);
  cursor: pointer;
  border: 2px solid white;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
}

.active-call-slider::-moz-range-thumb {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: var(--accent);
  cursor: pointer;
  border: 2px solid white;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
}

.active-call-value {
  font-weight: 600;
  color: var(--accent);
  font-size: 1rem;
}

.active-call-preview {
  background: rgba(138, 127, 141, 0.1);
  border-radius: 8px;
  padding: 12px;
  margin-top: 16px;
  font-size: 0.85rem;
  line-height: 1.5;
}

.active-call-preview p {
  margin: 4px 0;
}

/* 新增：预设模式按钮 */
.preset-buttons {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 8px;
  margin-top: 12px;
}

.preset-btn {
  padding: 8px;
  border: 1px solid var(--accent-gray);
  border-radius: 6px;
  background: white;
  color: var(--text);
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.2s;
  text-align: center;
}

.preset-btn:hover {
  background: var(--accent-gray-light);
  color: white;
  border-color: var(--accent-gray-light);
}

.preset-btn.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}

/* 背景设置区域 */
.background-controls {
  background: rgba(255, 255, 255, 0.5);
  border-radius: 10px;
  padding: 16px;
  margin-bottom: 20px;
}

.background-item {
  margin-bottom: 16px;
}

.background-item:last-child {
  margin-bottom: 0;
}

.background-preview {
  width: 100%;
  height: 150px;
  border-radius: 10px;
  overflow: hidden;
  margin-bottom: 12px;
  border: 2px dashed rgba(92, 92, 92, 0.3);
  display: flex;
  align-items: center;
  justify-content: center;
  background-size: cover;
  background-position: center;
  position: relative;
}

.background-preview.empty {
  background: rgba(255, 255, 255, 0.3);
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  gap: 8px;
}

.background-preview.empty i {
  font-size: 2rem;
  color: rgba(92, 92, 92, 0.3);
}

.background-preview.empty span {
  font-size: 0.85rem;
  color: rgba(92, 92, 92, 0.5);
}

.background-preview img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.background-options {
  display: flex;
  flex-direction: column;
  gap: 10px;
  margin-bottom: 16px;
}

.background-option {
  width: 100%;
  height: 60px;
  border-radius: 8px;
  overflow: hidden;
  cursor: pointer;
  border: 2px solid transparent;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
}

.background-option:hover {
  transform: scale(1.02);
}

.background-option.active {
  border-color: var(--accent);
}

.background-option img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.background-option.color {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.9rem;
  color: white;
  font-weight: 500;
  background: #f5f5f5;
  color: var(--text);
}

.background-option.color span {
  position: relative;
  z-index: 2;
}

.background-actions {
  display: flex;
  gap: 10px;
  margin-top: 16px;
}

.background-upload-btn {
  flex: 1;
}

/* 修改：恢复默认背景按钮改为灰色 */
.remove-background-btn {
  background: var(--accent-gray);
  color: white;
  border: none;
  padding: 12px;
  border-radius: 10px;
  cursor: pointer;
  transition: all 0.2s ease;
  width: 100%;
  margin-top: 10px;
}

.remove-background-btn:hover {
  background: var(--accent-gray-light);
}

/* 塔罗牌设置区域 */
.tarot-controls {
  background: rgba(255, 255, 255, 0.5);
  border-radius: 10px;
  padding: 16px;
  margin-bottom: 20px;
}

.tarot-item {
  margin-bottom: 16px;
}

.tarot-item:last-child {
  margin-bottom: 0;
}

.tarot-switch {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 16px;
  padding: 12px;
  background: var(--tarot-bg);
  border-radius: 10px;
  border-left: 4px solid var(--tarot-text);
}

.tarot-switch-label {
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 500;
  color: var(--tarot-text);
}

.tarot-switch-label i {
  font-size: 1.2rem;
}

.tarot-count-control {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 16px;
}

.tarot-count-label {
  font-size: 0.9rem;
  font-weight: 500;
  color: var(--text);
}

.tarot-number-selector {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-bottom: 16px;
}

.tarot-number {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.9rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  border: 2px solid transparent;
}

.tarot-number:hover {
  background: rgba(138, 127, 141, 0.2);
}

.tarot-number.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent-light);
}

.tarot-textarea {
  width: 100%;
  height: 200px;
  padding: 12px;
  border: 1px solid rgba(92, 92, 92, 0.2);
  border-radius: 10px;
  background: rgba(255, 255, 255, 0.7);
  font-size: 0.85rem;
  line-height: 1.4;
  resize: vertical;
  margin-bottom: 12px;
  box-sizing: border-box;
}

.tarot-textarea:focus {
  outline: none;
  border-color: var(--tarot-text);
  background: rgba(255, 255, 255, 0.9);
}

.tarot-info {
  display: flex;
  justify-content: space-between;
  margin-bottom: 16px;
  font-size: 0.85rem;
  color: rgba(92, 92, 92, 0.7);
}

.tarot-status {
  padding: 8px 12px;
  background: var(--tarot-bg);
  border-radius: 8px;
  font-size: 0.85rem;
  color: var(--tarot-text);
  margin-top: 16px;
  border-left: 3px solid var(--tarot-text);
}

/* 隐藏的文件输入 */
.hidden-file-input {
  display: none;
}

/* 滚动条样式 */
::-webkit-scrollbar {
  width: 5px;
}

::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.05);
  border-radius: 8px;
}

::-webkit-scrollbar-thumb {
  background: rgba(92, 92, 92, 0.3);
  border-radius: 8px;
}

::-webkit-scrollbar-thumb:hover {
  background: rgba(92, 92, 92, 0.5);
}

/* 响应式设计 */
@media (max-width: 768px) {
  .container {
    height: 95vh;
    padding: 10px;
    gap: 10px;
  }
  
  .chat-header {
    padding: 5px 0;
  }
  
  .chat-title-area h1 {
    font-size: 1.4rem;
  }
  
  .settings-panel {
    width: 100%;
    right: -100%;
  }
  
  .user-info {
    width: 65px;
  }
  
  .avatar {
    width: 40px;
    height: 40px;
  }
  
  .status-indicator {
    right: 8px;
    width: 8px;
    height: 8px;
  }
  
  .date-inputs {
    flex-direction: column;
  }
  
  .tab-button {
    min-width: 70px;
    padding: 10px 8px;
    font-size: 0.8rem;
  }
  
  .chat-subtitle {
    font-size: 0.7rem;
  }
  
  .love-days {
    font-size: 0.65rem;
    padding: 2px 6px;
  }
  
  .communication-buttons {
    flex-direction: column;
  }
  
  .input-area-buttons {
    flex-wrap: wrap;
  }
  
  .background-options {
    grid-template-columns: repeat(2, 1fr);
  }
  
  .tarot-number-selector {
    justify-content: center;
  }
  
  .message-actions {
    top: -45px;
  }
  
  .message-action-btn {
    padding: 8px 12px;
    font-size: 0.75rem;
  }
  
  /* 移动端调整输入框布局 */
  .message-input {
    min-width: 120px;
  }
  
  .continue-button {
    width: 40px;
    height: 40px;
    font-size: 1.3rem;
  }
  
  .upload-image-button {
    width: 40px;
    height: 40px;
  }
  
  .send-button {
    padding: 12px 16px;
  }
  
  .preset-buttons {
    grid-template-columns: repeat(2, 1fr);
  }
}



/* 遮罩层 */
.settings-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.4);
  backdrop-filter: blur(2px);
  z-index: 999;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s, visibility 0.3s;
}

.settings-overlay.active {
  opacity: 1;
  visibility: visible;
}

/* 通知样式 */
.notification {
  position: fixed;
  bottom: 15px;
  right: 15px;
  background: var(--accent);
  color: white;
  padding: 10px 16px;
  border-radius: 8px;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
  z-index: 1000;
  animation: fadeInOut 3s ease;
  font-size: 0.85rem;
  max-width: 300px;
}

@keyframes fadeInOut {
  0% { opacity: 0; transform: translateY(10px); }
  10% { opacity: 1; transform: translateY(0); }
  90% { opacity: 1; transform: translateY(0); }
  100% { opacity: 0; transform: translateY(10px); }
}

/* 通话/视频小窗口 */
.call-window, .video-window {
  position: fixed;
  width: 40mm;
  height: 40mm;
  min-width: 200px;
  min-height: 150px;
  max-width: 90vw;
  max-height: 90vh;
  background: var(--bg-panel);
  backdrop-filter: blur(8px);
  border-radius: 12px;
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
  z-index: 2000;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  resize: both;
  cursor: move;
  border: 1px solid rgba(92, 92, 92, 0.2);
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  touch-action: none;
}

.call-window:hover, .video-window:hover {
  box-shadow: 0 12px 30px rgba(0, 0, 0, 0.25);
}

.call-window {
  border-top: 4px solid #000000;
}

.video-window {
  border-top: 4px solid #000000;
}

.call-window.active, .video-window.active {
  transform: scale(1.02);
  box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
}

.window-header {
  padding: 10px 12px;
  background: rgba(255, 255, 255, 0.9);
  border-bottom: 1px solid rgba(92, 92, 92, 0.1);
  display: flex;
  justify-content: space-between;
  align-items: center;
  cursor: move;
  touch-action: none;
}

.window-title {
  font-size: 0.9rem;
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 6px;
}

.window-title i {
  font-size: 1rem;
}

.call-window .window-title {
  color: #000000;
}

.video-window .window-title {
  color: #000000;
}

.window-controls {
  display: flex;
  gap: 6px;
}

.window-btn {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  border: none;
  background: rgba(92, 92, 92, 0.1);
  color: var(--text);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.2s;
  touch-action: manipulation;
}

.window-btn:hover {
  background: rgba(92, 92, 92, 0.2);
}

.window-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 15px;
}

.call-avatar, .video-avatar {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  overflow: hidden;
  margin-bottom: 10px;
  border: 2px solid;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.5rem;
}

.call-avatar {
  border-color: #000000;
}

.video-avatar {
  border-color: #000000;
}

.call-avatar img, .video-avatar img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.calling-text {
  font-size: 0.8rem;
  color: var(--text);
  margin-bottom: 10px;
  text-align: center;
}

.in-call-text {
  font-size: 0.75rem;
  color: #333;
  background: rgba(0, 0, 0, 0.05);
  padding: 4px 8px;
  border-radius: 6px;
  margin-bottom: 10px;
  font-weight: 500;
}

.call-timer {
  font-size: 0.9rem;
  font-weight: 600;
  color: var(--text);
  margin-bottom: 12px;
  font-family: monospace;
}

.call-buttons {
  display: flex;
  gap: 8px;
  margin-top: 10px;
}

.accept-btn, .reject-btn, .end-btn {
  padding: 8px 16px;
  border: none;
  border-radius: 20px;
  font-size: 0.8rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
  min-width: 70px;
  touch-action: manipulation;
}

.accept-btn {
  background: var(--online);
  color: white;
}

.accept-btn:hover {
  background: #3d8b40;
}

.reject-btn {
  background: #f44336;
  color: white;
}

.reject-btn:hover {
  background: #d32f2f;
}

.end-btn {
  background: #f44336;
  color: white;
}

.end-btn:hover {
  background: #d32f2f;
}

/* 通话记录消息样式 */
.call-message, .video-message {
  background: rgba(0, 0, 0, 0.1);
  border-left: 3px solid #000000;
  color: #000000;
}

.video-message {
  background: rgba(0, 0, 0, 0.1);
  border-left: 3px solid #000000;
  color: #000000;
}

/* 塔罗牌消息样式 */
.tarot-message {
  background: var(--tarot-bg);
  border-left: 3px solid var(--tarot-text);
  color: var(--tarot-text);
}

/* 设置图标字体 */
@font-face {
  font-family: 'Material Icons';
  font-style: normal;
  font-weight: 400;
  src: url(https://fonts.gstatic.com/s/materialicons/v139/flUhRq6tzZclQEJ-Vdg-IuiaDsNc.woff2) format('woff2');
}

.material-icons {
  font-family: 'Material Icons';
  font-weight: normal;
  font-style: normal;
  font-size: 20px;
  line-height: 1;
  letter-spacing: normal;
  text-transform: none;
  display: inline-block;
  white-space: nowrap;
  word-wrap: normal;
  direction: ltr;
  -webkit-font-feature-settings: 'liga';
  -webkit-font-smoothing: antialiased;
}

/* 昵称编辑框 */
.nickname-input {
  background: transparent;
  border: none;
  border-bottom: 1px solid var(--accent);
  color: var(--text);
  font-size: 0.8rem;
  text-align: center;
  width: 100%;
  outline: none;
  padding: 2px 0;
}

/* 模态框样式 */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(3px);
  z-index: 2000;
  display: flex;
  justify-content: center;
  align-items: center;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s, visibility 0.3s;
}

.modal-overlay.active {
  opacity: 1;
  visibility: visible;
}

.modal-content {
  background: var(--bg-panel);
  backdrop-filter: blur(12px);
  border-radius: 18px;
  padding: 24px;
  width: 90%;
  max-width: 350px;
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
}

.modal-title {
  margin-top: 0;
  margin-bottom: 16px;
  color: var(--accent);
  font-weight: 400;
  text-align: center;
  font-size: 1.3rem;
}

.avatar-preview {
  width: 100px;
  height: 100px;
  border-radius: 50%;
  overflow: hidden;
  margin: 0 auto 16px;
  border: 2px solid var(--accent);
  background-color: white;
  display: flex;
  align-items: center;
  justify-content: center;
}

.avatar-preview img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.modal-buttons {
  display: flex;
  gap: 8px;
  margin-top: 16px;
}

.modal-btn {
  flex: 1;
  padding: 10px;
  border: none;
  border-radius: 8px;
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.2s;
}

.modal-btn.primary {
  background: var(--accent-gray);
  color: white;
}

.modal-btn.secondary {
  background: rgba(92, 92, 92, 0.1);
  color: var(--text);
}

.modal-btn:hover {
  opacity: 0.9;
  transform: translateY(-2px);
}

/* 开关样式 */
.switch {
  position: relative;
  display: inline-block;
  width: 50px;
  height: 26px;
}

.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  transition: .4s;
  border-radius: 34px;
}

.slider:before {
  position: absolute;
  content: "";
  height: 18px;
  width: 18px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  transition: .4s;
  border-radius: 50%;
}

input:checked + .slider {
  background-color: var(--tarot-text);
}

input:checked + .slider:before {
  transform: translateX(24px);
}

/* ===== 音乐播放器小窗样式 ===== */
.music-window {
  position: fixed;
  width: 360px;
  height: 200px;
  background: rgba(245, 245, 245, 0.95);
  backdrop-filter: blur(15px);
  border-radius: 24px;
  box-shadow: 0 12px 35px rgba(0, 0, 0, 0.2);
  z-index: 2000;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  resize: none;
  cursor: move;
  border: 1px solid rgba(255, 255, 255, 0.3);
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  touch-action: none;
  border-top: 4px solid #a99cad;
}

.music-window:hover {
  box-shadow: 0 18px 45px rgba(0, 0, 0, 0.25);
  transform: scale(1.02);
}

.music-window .window-header {
  background: rgba(255, 255, 255, 0.7);
  border-bottom: 1px solid rgba(138, 127, 141, 0.2);
}

.music-window .window-title {
  color: #8a7f8d;
  font-weight: 500;
}

/* CD唱片容器 */
.music-cd-container {
  display: flex;
  align-items: center;
  padding: 12px 16px;
  gap: 16px;
  flex: 1;
}

/* CD唱片 */
.music-cd {
  width: 100px;
  height: 100px;
  border-radius: 50%;
  background: linear-gradient(45deg, #2c3e50, #3498db);
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 8px 20px rgba(0,0,0,0.2);
  position: relative;
  flex-shrink: 0;
  animation: cdSpin 8s linear infinite;
  animation-play-state: paused;
  cursor: pointer;
  transition: all 0.3s ease;
}

.music-cd.playing {
  animation-play-state: running;
}

.music-cd::before {
  content: '';
  position: absolute;
  width: 30px;
  height: 30px;
  border-radius: 50%;
  background: rgba(255,255,255,0.2);
  border: 2px dashed rgba(255,255,255,0.5);
}

.music-cd::after {
  content: '';
  position: absolute;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: rgba(255,255,255,0.8);
  box-shadow: 0 0 10px rgba(255,255,255,0.8);
}

.music-cd img {
  width: 60%;
  height: 60%;
  border-radius: 50%;
  object-fit: cover;
  border: 2px solid rgba(255,255,255,0.5);
}

@keyframes cdSpin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

/* 音乐信息 */
.music-info {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.music-title {
  font-size: 1rem;
  font-weight: 600;
  color: #5c5c5c;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  margin-bottom: 4px;
}

.music-artist {
  font-size: 0.75rem;
  color: #888;
  display: flex;
  align-items: center;
  gap: 4px;
}

/* 进度条 */
.music-progress-container {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.music-progress-bar {
  width: 100%;
  height: 6px;
  background: rgba(0,0,0,0.1);
  border-radius: 3px;
  position: relative;
  cursor: pointer;
}

.music-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #a99cad, #8a7f8d);
  border-radius: 3px;
  width: 0%;
  position: relative;
  transition: width 0.1s linear;
}

.music-progress-handle {
  width: 14px;
  height: 14px;
  background: white;
  border: 2px solid #8a7f8d;
  border-radius: 50%;
  position: absolute;
  right: -7px;
  top: -4px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
  opacity: 0;
  transition: opacity 0.2s;
}

.music-progress-bar:hover .music-progress-handle {
  opacity: 1;
}

/* 时间显示 */
.music-time {
  display: flex;
  justify-content: space-between;
  font-size: 0.7rem;
  color: #666;
}

/* 控制按钮 */
.music-controls-bar {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-top: 4px;
}

.music-control-btn {
  width: 30px;
  height: 30px;
  border-radius: 50%;
  border: none;
  background: rgba(138, 127, 141, 0.1);
  color: #5c5c5c;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s;
}

.music-control-btn:hover {
  background: #8a7f8d;
  color: white;
  transform: scale(1.1);
}

.music-control-btn i {
  font-size: 1.1rem;
}

/* 音乐库列表样式 */
.music-list {
  max-height: 250px;
  overflow-y: auto;
  border-radius: 12px;
  background: rgba(255,255,255,0.5);
  padding: 8px;
}

.music-item-card {
  display: flex;
  align-items: center;
  padding: 10px;
  border-radius: 10px;
  background: white;
  margin-bottom: 6px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.05);
  transition: all 0.2s;
}

.music-item-card:hover {
  background: rgba(138, 127, 141, 0.1);
  transform: translateY(-2px);
}

.music-item-icon {
  width: 36px;
  height: 36px;
  border-radius: 8px;
  background: linear-gradient(135deg, #a99cad, #8a7f8d);
  display: flex;
  align-items: center;
  justify-content: center;
  margin-right: 12px;
  color: white;
}

.music-item-info {
  flex: 1;
  overflow: hidden;
}

.music-item-name {
  font-size: 0.85rem;
  font-weight: 500;
  color: #5c5c5c;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.music-item-size {
  font-size: 0.65rem;
  color: #888;
}

.music-item-actions {
  display: flex;
  gap: 8px;
}

.music-item-play {
  padding: 6px 12px;
  border: none;
  border-radius: 16px;
  background: #8a7f8d;
  color: white;
  font-size: 0.7rem;
  cursor: pointer;
  transition: all 0.2s;
}

.music-item-delete {
  padding: 6px;
  border: none;
  border-radius: 50%;
  background: rgba(244, 67, 54, 0.1);
  color: #f44336;
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s;
}

.music-item-delete:hover {
  background: #f44336;
  color: white;
}

.music-empty {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 30px;
  color: #888;
  gap: 10px;
}

.music-upload-area {
  width: 100%;
  height: 120px;
  border: 2px dashed #bdbdbd;
  border-radius: 16px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s;
  margin-bottom: 16px;
  background: rgba(255,255,255,0.5);
}

.music-upload-area:hover {
  border-color: #8a7f8d;
  background: rgba(138, 127, 141, 0.1);
}

/* 移动端适配 */
@media (max-width: 768px) {
  .music-window {
    width: 300px;
    height: 180px;
  }
  
  .music-cd {
    width: 70px;
    height: 70px;
  }
  
  .music-window .window-content {
    padding: 10px;
  }
  
  .call-window, .video-window {
    width: 70mm;
    height: 90mm;
    max-width: 85vw;
    max-height: 95vw;
  }
  
  .call-window .call-buttons,
  .video-window .call-buttons {
    flex-direction: column;
    gap: 10px;
    margin-top: 15px;
  }
  
  .accept-btn, .reject-btn, .end-btn {
    width: 100%;
    padding: 14px;
    font-size: 0.9rem;
  }
}
</style>
</head>
<body>
<!-- 背景图片容器 -->
<div class="background-container" id="backgroundContainer"></div>

<div class="container">
  <!-- 设置遮罩层 -->
  <div class="settings-overlay" id="settingsOverlay"></div>
  
  <!-- 用户信息编辑模态框 -->
  <div class="modal-overlay" id="userModal">
    <div class="modal-content">
      <h3 class="modal-title" id="modalTitle">编辑用户信息</h3>
      
      <div class="avatar-preview" id="avatarPreview">
        <!-- 头像预览 -->
      </div>
      
      <div style="margin-bottom: 16px;">
        <label style="display:block; margin-bottom:6px; color:var(--text); font-size:0.85rem;">昵称:</label>
        <input type="text" class="nickname-input" id="modalNicknameInput" maxlength="12" style="width:100%; padding:8px; border-radius:6px; border:1px solid rgba(92,92,92,0.3); font-size:0.85rem;">
      </div>
      
      <div style="margin-bottom: 16px;">
        <label style="display:block; margin-bottom:6px; color:var(--text); font-size:0.85rem;">更换头像:</label>
        <input type="file" id="modalAvatarUpload" class="hidden-file-input" accept="image/*">
        <button class="add-sticker-btn" id="uploadAvatarBtn" style="margin-bottom:0; padding:10px; font-size:0.85rem;">选择头像图片</button>
      </div>
      
      <div class="modal-buttons">
        <button class="modal-btn secondary" id="cancelEditBtn">取消</button>
        <button class="modal-btn primary" id="saveUserInfoBtn">保存</button>
      </div>
    </div>
  </div>
  
  <!-- 聊天头部 -->
  <div class="chat-header">
    <!-- 左侧用户信息（对方） -->
    <div class="user-info" id="otherUserInfo">
      <div class="avatar" id="otherAvatar">
        <!-- 白色圆形，无文字无默认图片 -->
      </div>
      <div class="status-indicator" id="otherStatusIndicator"></div>
      <div class="status-text" id="otherStatusText">在DR</div>
      <div class="mood-percentage" id="otherMoodPercentage">
        <span style="font-size:0.6rem; margin-right:2px;">心情指数:</span>
        <span id="otherMoodValue">85%</span>
      </div>
      <div class="nickname" id="otherNickname">对方</div>
    </div>
    
    <!-- 中间标题 -->
    <div class="chat-title-area">
      <h1 id="appTitle">梦角爱人</h1>
      <div class="love-days" id="loveDays">
        <i class="material-icons">favorite</i>
        <span id="loveDaysCount">恋爱第 0 天</span>
      </div>
      <div class="chat-subtitle" id="appSubtitle">绝对私密的一对一聊天空间</div>
    </div>
    
    <!-- 右侧用户信息（自己）和设置按钮 -->
    <div style="display: flex; align-items: center; gap: 10px;">
      <div class="user-info" id="selfUserInfo">
        <div class="avatar" id="selfAvatar">
          <!-- 白色圆形，无文字无默认图片 -->
        </div>
        <div class="status-text" id="selfStatusText">在线</div>
        <div class="nickname" id="selfNickname">我</div>
      </div>
      
      <!-- ===== 新增：夜间模式切换按钮 ===== -->
      <div class="theme-toggle" id="themeToggle">
        <i class="material-icons">dark_mode</i> <!-- 默认显示月亮图标 -->
      </div>
      
      <div class="settings-toggle" id="settingsToggle">
        <i class="material-icons">settings</i>
      </div>
    </div>
  </div>
  
  <!-- 聊天区域 -->
  <section class="chat-section">
    <div class="chat-container">
      <div class="messages-area" id="messagesArea">
        <!-- 对方正在输入指示器 -->
        <div class="typing-indicator" id="typingIndicator">
          <div class="dot"></div>
          <div class="dot"></div>
          <div class="dot"></div>
          <span style="font-size:0.75rem; margin-left:4px;">对方正在输入...</span>
        </div>
        
        <!-- 初始消息将从本地存储加载 -->
      </div>
      
      <div class="input-area">
        <div class="input-area-buttons">
          <input type="text" class="message-input" id="messageInput" placeholder="输入消息..." maxlength="200">
          <div class="upload-image-button" id="uploadImageButton" title="发送图片">
            <i class="material-icons">image</i>
          </div>
          <input type="file" id="imageUpload" class="hidden-file-input" accept="image/*">
          <button class="continue-button" id="continueButton">...</button>
          <button class="send-button" id="sendButton">发送</button>
        </div>
      </div>
    </div>
  </section>
</div>

<!-- 设置面板 -->
<div class="settings-panel" id="settingsPanel">
  <div class="settings-header">
    <h2>设置</h2>
    <button class="close-settings" id="closeSettings">
      <i class="material-icons">close</i>
    </button>
  </div>
  
  <div class="settings-tabs">
    <button class="tab-button active" data-tab="stickers">表情包库</button>
    <button class="tab-button" data-tab="phrases">回复词条</button>
    <button class="tab-button" data-tab="tarot">塔罗牌字卡抽取🔮</button>
    <button class="tab-button" data-tab="ratio">发送设置</button>
    <button class="tab-button" data-tab="appearance">外观设置</button>
    <button class="tab-button" data-tab="background">背景设置</button>
    <button class="tab-button" data-tab="communication">通话视频</button>
    <button class="tab-button" data-tab="music">🎵 音乐播放</button>
    <!-- 云导入和导出记录标签页已删除 -->
  </div>
  
  <div class="settings-content">
    <!-- 表情包库标签页 -->
    <div class="tab-content active" id="stickersTab">
      <div class="sticker-library">
        <h3>表情包库管理</h3>
        <p>添加图片后，对方可以随机发送这些表情包作为回复</p>
        
        <div class="sticker-preview" id="stickerPreview">
          <!-- 表情包将在这里显示 -->
          <div class="sticker-item" id="addStickerPlaceholder">
            <div class="sticker-placeholder">+</div>
          </div>
        </div>
        
        <input type="file" id="stickerUpload" class="hidden-file-input" accept="image/*" multiple>
        <button class="add-sticker-btn" id="addStickerBtn">从相册添加表情包</button>
        
        <p style="font-size:0.75rem; margin-top:16px; color:#888;">
          提示：点击表情包右上角的×可以删除。已添加 <span id="stickerCount">0</span> 个表情包
        </p>
      </div>
    </div>
    
    <!-- 回复词条标签页 -->
    <div class="tab-content" id="phrasesTab">
      <div class="phrases-library">
        <h3>回复词条管理</h3>
        <p style="margin-bottom: 8px;">对方将从这些词条中随机抽取作为回复。每行一个词条，自动识别分行。</p>
        <p style="font-size:0.75rem; color:#888; margin-bottom: 16px;">提示：点击任意消息可以引用or删除or撤回</p>
        
        <textarea class="phrases-textarea" id="phrasesTextarea" placeholder="请输入回复词条，每行一个&#10;例如：&#10;好的，明白了&#10;这很有趣&#10;继续聊吧&#10;让我想想"></textarea>
        
        <div class="phrases-info">
          <span>当前词条数: <span id="phraseCount">0</span></span>
          <span>随机混合表情包和字卡发送</span>
        </div>
        
        <button class="save-phrases-btn" id="savePhrasesBtn">保存词条</button>
        
        <p style="font-size:0.75rem; margin-top:16px; color:#888;">
          提示：保存后，对方将从这些词条和表情包中随机选择，随机混合发送<br>
          （塔罗牌模式开启时，将优先使用塔罗牌字卡）
        </p>
      </div>
    </div>
    
    <!-- 塔罗牌字卡抽取标签页 -->
    <div class="tab-content" id="tarotTab">
      <div class="tarot-library">
        <h3>塔罗牌字卡抽取🔮</h3>
        <p>开启塔罗牌梦占模式，对方将只抽取塔罗牌字卡进行回复</p>
        
        <div class="tarot-controls">
          <div class="tarot-switch">
            <div class="tarot-switch-label">
              <i class="material-icons">auto_awesome</i>
              <span>塔罗牌梦占模式</span>
            </div>
            <label class="switch">
              <input type="checkbox" id="tarotModeToggle">
              <span class="slider"></span>
            </label>
          </div>
          
          <div class="tarot-item">
            <div class="tarot-count-control">
              <div class="tarot-count-label">每次抽取数量:</div>
              <div id="tarotCountValue">1</div>
            </div>
            
            <div class="tarot-number-selector" id="tarotNumberSelector">
              <!-- 数字1-15将通过JS动态生成 -->
            </div>
          </div>
          
          <div class="tarot-item">
            <label class="communication-label">塔罗牌字卡库:</label>
            <textarea class="tarot-textarea" id="tarotTextarea" placeholder="请输入塔罗牌字卡，每行一个&#10;例如：&#10;愚人 正位&#10;魔术师 逆位&#10;女祭司 正位&#10;世界 逆位"></textarea>
            
            <div class="tarot-info">
              <span>当前塔罗牌字卡数: <span id="tarotPhraseCount">0</span></span>
              <span>每行一个字卡</span>
            </div>
          </div>
          
          <button class="save-tarot-btn" id="saveTarotBtn">保存塔罗牌设置</button>
          
          <div class="tarot-status" id="tarotStatus">
            塔罗牌模式已关闭，对方使用普通词条和表情包回复
          </div>
          
          <!-- 塔罗牌操作按钮 -->
          <div style="display: flex; gap: 10px; margin-top: 16px;">
            <button class="add-sticker-btn" id="loadDefaultTarotBtn" style="flex: 1; padding: 10px;">加载默认78张塔罗牌</button>
            <button class="add-sticker-btn" id="clearTarotBtn" style="flex: 1; padding: 10px; background: #888;">清空塔罗牌库</button>
          </div>
          
          <div style="margin-top: 16px; padding: 12px; background: rgba(255, 255, 255, 0.5); border-radius: 8px; border-left: 3px solid var(--tarot-text);">
            <p style="margin: 0 0 8px 0; font-size: 0.85rem; font-weight: 500; color: var(--tarot-text);">抽取规则说明：</p>
            <p style="margin: 4px 0; font-size: 0.75rem; color: #666;">
              • 智能识别牌名：支持"愚人 正位"、"正位·魔术师"、"逆位-女祭司"等多种格式
            </p>
            <p style="margin: 4px 0; font-size: 0.75rem; color: #666;">
              • 同牌正逆位不重复：抽到"愚人 正位"后，不会再抽"愚人 逆位"
            </p>
          </div>
        </div>
        
        <p style="font-size:0.75rem; margin-top:16px; color:#888;">
          提示：开启塔罗牌模式后，对方回复将只从塔罗牌字卡库中抽取<br>
          可以设置每次抽取1-15张塔罗牌字卡<br>
          <strong>智能规则：同牌正逆位不重复抽取</strong>
        </p>
      </div>
    </div>
    
    <!-- 发送设置标签页 -->
    <div class="tab-content" id="ratioTab">
      <div class="ratio-library">
        <h3>发送设置</h3>
        <p>调整对方回复时表情包和字卡的发送比例</p>
        
        <div class="ratio-controls">
          <div class="ratio-item">
            <div class="ratio-label">
              <span>表情包发送比例</span>
              <span class="ratio-value" id="stickerRatioValue">50%</span>
            </div>
            <input type="range" min="0" max="100" value="50" class="ratio-slider" id="stickerRatioSlider">
          </div>
          
          <div class="ratio-item">
            <div class="ratio-label">
              <span>字卡发送比例</span>
              <span class="ratio-value" id="phraseRatioValue">50%</span>
            </div>
            <input type="range" min="0" max="100" value="50" class="ratio-slider" id="phraseRatioSlider">
          </div>
          
          <div class="max-count-control">
            <div class="max-count-label">最大发送数量:</div>
            <select class="max-count-select" id="maxMessageCount">
              <option value="1">1条</option>
              <option value="2">2条</option>
              <option value="3" selected>3条</option>
              <option value="4">4条</option>
              <option value="5">5条</option>
            </select>
          </div>
          
          <div class="auto-send-controls">
            <div class="auto-send-label">主动发送频率:</div>
            <select class="auto-send-select" id="autoSendFrequency">
              <option value="0">不主动发送</option>
              <option value="300000">5分钟</option>
              <option value="600000" selected>10分钟</option>
              <option value="1200000">20分钟</option>
              <option value="1800000">30分钟</option>
              <option value="3600000">1小时</option>
            </select>
          </div>
        </div>
        
        <p style="font-size:0.75rem; margin-top:16px; color:#888;">
          提示：对方回复时会根据此比例随机混合发送表情包和字卡<br>
          对方也会根据设置的频率主动发送消息<br>
          （塔罗牌模式开启时，将忽略此比例设置，只抽取塔罗牌字卡）
        </p>
      </div>
    </div>
    
    <!-- 外观设置标签页 -->
    <div class="tab-content" id="appearanceTab">
      <div class="appearance-library">
        <h3>外观设置</h3>
        <p>自定义聊天界面的外观和显示信息</p>
        
        <div class="appearance-controls">
          <div class="appearance-item">
            <label class="appearance-label">应用标题:</label>
            <input type="text" class="appearance-input" id="appTitleInput" value="梦角爱人" maxlength="20">
          </div>
          
          <div class="appearance-item">
            <label class="appearance-label">应用副标题:</label>
            <input type="text" class="appearance-input" id="appSubtitleInput" value="绝对私密的一对一聊天空间" maxlength="50">
          </div>
          
          <div class="appearance-item">
            <label class="appearance-label">恋爱起始日期:</label>
            <div class="date-inputs">
              <input type="number" class="date-input" id="loveYear" placeholder="年" min="2000" max="2100" value="2024">
              <input type="number" class="date-input" id="loveMonth" placeholder="月" min="1" max="12" value="1">
              <input type="number" class="date-input" id="loveDay" placeholder="日" min="1" max="31" value="1">
            </div>
          </div>
          
          <div class="appearance-item">
            <label class="appearance-label">对方心情变化频率:</label>
            <select class="appearance-input" id="moodChangeFrequency">
              <option value="60000">1分钟</option>
              <option value="300000">5分钟</option>
              <option value="600000" selected>10分钟</option>
              <option value="1200000">20分钟</option>
              <option value="1800000">30分钟</option>
            </select>
          </div>
        </div>
        
        <button class="save-phrases-btn" id="saveAppearanceBtn">保存外观设置</button>
        
        <p style="font-size:0.75rem; margin-top:16px; color:#888;">
          提示：保存后，应用标题、副标题和恋爱天数将立即更新
        </p>
      </div>
    </div>
    
    <!-- 背景设置标签页 -->
    <div class="tab-content" id="backgroundTab">
      <div class="background-library">
        <h3>背景设置</h3>
        <p>自定义聊天背景，可以选择预设背景或上传自己的图片</p>
        
        <div class="background-controls">
          <div class="background-item">
            <label class="communication-label">当前背景预览:</label>
            <div class="background-preview" id="backgroundPreview">
              <div class="empty">
                <i class="material-icons">wallpaper</i>
                <span>默认背景</span>
              </div>
            </div>
          </div>
          
          <div class="background-item">
            <label class="communication-label">上传背景图片:</label>
            <div class="background-options">
              <div class="background-option color" id="uploadBackgroundOption">
                <span>点击上传背景图片</span>
              </div>
            </div>
            <input type="file" id="backgroundUpload" class="hidden-file-input" accept="image/*">
          </div>
          
          <div class="background-item">
            <label class="communication-label">背景透明度:</label>
            <input type="range" min="0" max="100" value="100" class="ratio-slider" id="backgroundOpacitySlider">
            <div style="display:flex; justify-content:space-between; margin-top:8px;">
              <span style="font-size:0.8rem;">透明</span>
              <span style="font-size:0.8rem;" id="backgroundOpacityValue">100%</span>
              <span style="font-size:0.8rem;">不透明</span>
            </div>
          </div>
          
          <button class="remove-background-btn" id="removeBackgroundBtn">恢复默认背景</button>
        </div>
        
        <button class="save-background-btn" id="saveBackgroundBtn">保存背景设置</button>
        
        <p style="font-size:0.75rem; margin-top:16px; color:#888;">
          提示：上传的图片会保存在本地，刷新页面不会丢失
        </p>
      </div>
    </div>
    
    <!-- 通信设置标签页 -->
    <div class="tab-content" id="communicationTab">
      <div class="communication-library">
        <h3>通话与视频</h3>
        <p>模拟通话和视频功能，对方可以主动邀请或响应用户的邀请</p>
        
        <div class="communication-controls">
          <div class="communication-item">
            <div class="communication-label">主动呼叫对方</div>
            <div class="communication-buttons">
              <button class="call-button" id="startCallButton">
                <i class="material-icons">call</i>
                语音通话
              </button>
              <button class="video-button" id="startVideoButton">
                <i class="material-icons">videocam</i>
                视频通话
              </button>
            </div>
          </div>
          
          <div class="communication-item">
            <div class="communication-label">通话设置</div>
            <div style="margin-top: 10px;">
              <label style="display:flex; align-items:center; gap:8px; font-size:0.85rem; margin-bottom:8px;">
                <input type="checkbox" id="autoAcceptCalls" checked>
                <span>自动接听对方来电</span>
              </label>
              <label style="display:flex; align-items:center; gap:8px; font-size:0.85rem;">
                <input type="checkbox" id="autoAcceptVideos" checked>
                <span>自动接听对方视频邀请</span>
              </label>
            </div>
          </div>
          
          <!-- 主动呼叫设置 -->
          <div class="active-call-controls">
            <div class="communication-label">对方主动呼叫设置</div>
            
            <div class="active-call-item">
              <div class="ratio-label">
                <span>总体呼叫频率</span>
                <span class="active-call-value" id="overallFrequencyValue">30%</span>
              </div>
              <input type="range" min="0" max="100" value="30" class="active-call-slider" id="overallFrequencySlider">
              <div style="display:flex; justify-content:space-between; margin-top:4px;">
                <span style="font-size:0.75rem; color:#888;">关闭</span>
                <span style="font-size:0.75rem; color:#888;">最高</span>
              </div>
            </div>
            
            <div class="active-call-item">
              <div class="ratio-label">
                <span>呼叫类型偏好</span>
                <span class="active-call-value" id="callPreferenceValue">电话 50% / 视频 50%</span>
              </div>
              <input type="range" min="0" max="100" value="50" class="active-call-slider" id="callPreferenceSlider">
              <div style="display:flex; justify-content:space-between; margin-top:4px;">
                <span style="font-size:0.75rem; color:#888;">纯电话</span>
                <span style="font-size:0.75rem; color:#888;">纯视频</span>
              </div>
            </div>
            
            <!-- 预设模式 -->
            <div class="active-call-item">
              <div class="ratio-label">
                <span>预设模式</span>
              </div>
              <div class="preset-buttons">
                <button class="preset-btn" data-preset="quiet">安静模式</button>
                <button class="preset-btn" data-preset="daily">日常模式</button>
                <button class="preset-btn" data-preset="intimate">亲密模式</button>
                <button class="preset-btn active" data-preset="custom">自定义</button>
              </div>
            </div>
            
            <!-- 详细预览 -->
            <div class="active-call-preview" id="activeCallPreview">
              <p><strong>当前设置预览：</strong></p>
              <p>• 总体频率：<span id="previewFrequency">中等 (30%)</span></p>
              <p>• 呼叫类型：<span id="previewType">电话 50% / 视频 50%</span></p>
              <p>• 预计每天：<span id="previewDaily">2-4次呼叫</span></p>
              <p>• 下次呼叫：<span id="previewNext">15-30分钟内</span></p>
            </div>
          </div>
          
          <div class="communication-stats">
            <p style="margin:0 0 8px 0; font-weight:500;">通话统计</p>
            <p style="margin:6px 0;">今日通话: <span id="todayCalls">0</span> 次</p>
            <p style="margin:6px 0;">总通话时长: <span id="totalCallTime">0</span> 分钟</p>
            <p style="margin:6px 0;">今日视频: <span id="todayVideos">0</span> 次</p>
            <p style="margin:6px 0;">总视频时长: <span id="totalVideoTime">0</span> 分钟</p>
            <p style="margin:6px 0; font-size:0.8rem; color:#666;">对方今日主动呼叫: <span id="todayIncomingCalls">0</span> 次</p>
          </div>
        </div>
        
        <button class="communication-btn" id="saveCommunicationBtn">保存通话设置</button>
        
        <p style="font-size:0.75rem; margin-top:16px; color:#888;">
          提示：通话/视频小窗口可以随意拖动位置（支持手机触摸拖动）<br>
          对方会根据您的设置主动发起通话或视频邀请
        </p>
      </div>
    </div>
    
    <!-- 音乐播放标签页 -->
    <div class="tab-content" id="musicTab">
      <div class="music-library">
        <h3>🎵 音乐播放器</h3>
        <p>上传音频文件，对方可以随机播放或主动发起听歌</p>
        
        <div class="music-controls">
          <div class="music-item">
            <label class="communication-label">上传音乐文件:</label>
            <div class="music-upload-area" id="musicUploadArea">
              <i class="material-icons" style="font-size: 2.5rem; color: var(--accent-gray);">music_note</i>
              <span style="color: var(--text); margin-top: 8px;">点击或拖拽上传音频</span>
              <span style="font-size: 0.75rem; color: #888; margin-top: 4px;">支持 MP3、WAV、OGG（建议大小不超过10MB）</span>
            </div>
            <input type="file" id="musicUpload" class="hidden-file-input" accept="audio/*">
          </div>
          
          <div class="music-item">
            <label class="communication-label">音乐库管理:</label>
            <div class="music-list" id="musicList">
              <!-- 音乐列表将通过JS动态生成 -->
              <div class="music-empty">
                <i class="material-icons">library_music</i>
                <span>暂无音乐，请上传音频文件</span>
              </div>
            </div>
          </div>
          
          <div class="music-item">
            <label class="communication-label">播放设置:</label>
            <div style="display: flex; flex-direction: column; gap: 12px;">
              <label style="display: flex; align-items: center; gap: 8px; font-size: 0.85rem;">
                <input type="checkbox" id="autoPlayMusic" checked>
                <span>对方主动播放音乐</span>
              </label>
              
              <div class="active-call-item">
                <div class="ratio-label">
                  <span>音乐播放频率</span>
                  <span class="active-call-value" id="musicFrequencyValue">30%</span>
                </div>
                <input type="range" min="0" max="100" value="30" class="active-call-slider" id="musicFrequencySlider">
                <div style="display:flex; justify-content:space-between; margin-top:4px;">
                  <span style="font-size:0.75rem; color:#888;">关闭</span>
                  <span style="font-size:0.75rem; color:#888;">最高</span>
                </div>
              </div>
              
              <div class="ratio-label">
                <span>播放模式</span>
              </div>
              <div style="display: flex; gap: 10px;">
                <label style="display: flex; align-items: center; gap: 4px; font-size: 0.8rem;">
                  <input type="radio" name="musicPlayMode" value="random" checked> 随机播放
                </label>
                <label style="display: flex; align-items: center; gap: 4px; font-size: 0.8rem;">
                  <input type="radio" name="musicPlayMode" value="single"> 单曲循环
                </label>
                <label style="display: flex; align-items: center; gap: 4px; font-size: 0.8rem;">
                  <input type="radio" name="musicPlayMode" value="list"> 列表循环
                </label>
              </div>
            </div>
          </div>
        </div>
        
        <button class="save-background-btn" id="saveMusicSettingsBtn" style="margin-top: 20px;">保存音乐设置</button>
        
        <p style="font-size:0.75rem; margin-top:16px; color:#888;">
          ⚡ 提示：音乐文件会保存在本地，不会上传到服务器<br>
          🎧 对方会根据设置主动播放音乐，聊天页面会出现可拖动的音乐小窗<br>
          💿 点击CD唱片可以暂停/播放，拖动进度条可以跳转
        </p>
      </div>
    </div>
    
    <!-- 云导入和导出记录标签页已删除 -->
  </div>
</div>

<!-- 通话/视频小窗口会动态创建 -->

<script>
// ========================
// 第一部分：从第一个代码文件移植的健壮存储逻辑
// ========================

/**
 * 数据存储管理类 - 完全移植自第一个代码文件
 * 特点：完善的异常处理、容量管理、数据完整性检查
 */
class ChatDataManager {
    constructor() {
        // 存储键名定义
        this.SELF_INFO_KEY = 'seven_and_wish_self_info';
        this.OTHER_INFO_KEY = 'seven_and_wish_other_info';
        this.MESSAGES_KEY = 'seven_and_wish_messages';
        this.PHRASES_KEY = 'seven_and_wish_phrases';
        this.STICKERS_KEY = 'seven_and_wish_stickers';
        this.SEND_SETTINGS_KEY = 'seven_and_wish_send_settings';
        this.APPEARANCE_KEY = 'seven_and_wish_appearance';
        this.BACKGROUND_KEY = 'seven_and_wish_background';
        this.TAROT_KEY = 'seven_and_wish_tarot_settings';
        this.COMMUNICATION_KEY = 'seven_and_wish_communication';
        this.DRAWN_CARDS_KEY = 'seven_and_wish_drawn_cards';
        this.LOVE_DAYS_KEY = 'seven_and_wish_love_days';
        this.READ_NO_REPLY_KEY = 'seven_and_wish_read_no_reply';
        this.TODAY_DATE_KEY = 'seven_and_wish_today_date';
        this.MUSIC_SETTINGS_KEY = 'seven_and_wish_music_settings';
        
        // 版本控制
        this.DATA_VERSION_KEY = 'seven_and_wish_data_version';
        this.DATA_VERSION = '2.0'; // 第二个文件的版本
        
        // 最大消息数量限制（防止数据过大）
        this.MAX_MESSAGES = 500;
        
        // 初始化数据
        this.initData();
    }
    
    /**
     * 初始化数据 - 只在完全没有数据时创建默认数据
     * 不会覆盖已有数据
     */
    initData() {
        // 检查是否需要初始化默认数据
        const hasAnyData = localStorage.getItem(this.SELF_INFO_KEY) !== null ||
                          localStorage.getItem(this.OTHER_INFO_KEY) !== null ||
                          localStorage.getItem(this.MESSAGES_KEY) !== null;
        
        if (!hasAnyData) {
            console.log('首次运行，创建默认数据');
            this.createDefaultData();
        }
        
        // 确保版本信息存在
        if (!localStorage.getItem(this.DATA_VERSION_KEY)) {
            localStorage.setItem(this.DATA_VERSION_KEY, this.DATA_VERSION);
        }
    }
    
    /**
     * 创建默认数据 - 只在第一次运行时调用
     */
    createDefaultData() {
        // 默认自己信息
        this.setStoredData(this.SELF_INFO_KEY, {
            nickname: '我',
            avatar: null,
            status: '在线'
        });
        
        // 默认对方信息
        this.setStoredData(this.OTHER_INFO_KEY, {
            nickname: '对方',
            avatar: null,
            status: '在DR',
            mood: 85
        });
        
        // 默认发送设置
        this.setStoredData(this.SEND_SETTINGS_KEY, {
            stickerRatio: 50,
            phraseRatio: 50,
            maxMessageCount: 3,
            autoSendFrequency: 600000
        });
        
        // 默认外观设置
        this.setStoredData(this.APPEARANCE_KEY, {
            appTitle: '梦角爱人',
            appSubtitle: '绝对私密的一对一聊天空间',
            loveStartDate: new Date(2024, 0, 1).toISOString(),
            moodChangeFrequency: 600000
        });
        
        // 默认背景设置
        this.setStoredData(this.BACKGROUND_KEY, {
            backgroundImage: null,
            opacity: 100
        });
        
        // 默认塔罗牌设置
        this.setStoredData(this.TAROT_KEY, {
            enabled: false,
            drawCount: 1,
            customPhrases: []
        });
        
        // 默认通信设置
        this.setStoredData(this.COMMUNICATION_KEY, {
            autoAcceptCalls: true,
            autoAcceptVideos: true,
            todayCalls: 0,
            todayVideos: 0,
            totalCallTime: 0,
            totalVideoTime: 0,
            todayIncomingCalls: 0,
            activeCallSettings: {
                enabled: true,
                overallFrequency: 30,
                callPreference: 50,
                presetMode: 'custom',
                minInterval: 15,
                maxInterval: 45,
                respectBusyStatus: true,
                timeSensitivity: true,
                adaptToActivity: true
            }
        });
        
        // 默认音乐设置
        this.setStoredData(this.MUSIC_SETTINGS_KEY, {
            musicList: [],
            autoPlayMusic: true,
            musicFrequency: 30,
            playMode: 'random'
        });
        
        // 默认回复词条
        this.setStoredData(this.PHRASES_KEY, [
            "好的，明白了",
            "这很有趣",
            "继续聊吧",
            "让我想想",
            "很有意思的观点",
            "我不太确定",
            "可以详细说说吗",
            "我同意",
            "这是个好问题",
            "谢谢分享"
        ]);
        
        // 默认消息（只有一条欢迎消息）
        this.setStoredData(this.MESSAGES_KEY, [{
            id: Date.now(),
            text: "你好！欢迎使用私密聊天。点击右上角的齿轮图标可以管理表情包和回复词条。",
            sender: "other",
            time: this.getFormattedTime(Date.now()),
            read: true
        }]);
        
        // 空的表情包
        this.setStoredData(this.STICKERS_KEY, []);
        
        // 已抽取塔罗牌记录
        this.setStoredData(this.DRAWN_CARDS_KEY, []);
        
        // 恋爱天数
        this.setStoredData(this.LOVE_DAYS_KEY, 1);
        
        // 已读不回记录
        this.setStoredData(this.READ_NO_REPLY_KEY, []);
        
        // 今日日期
        this.setStoredData(this.TODAY_DATE_KEY, new Date().toDateString());
        
        // 保存版本
        localStorage.setItem(this.DATA_VERSION_KEY, this.DATA_VERSION);
    }
    
    /**
     * 生成唯一消息ID
     */
    generateMessageId() {
        return 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }
    
    /**
     * 获取格式化时间
     */
    getFormattedTime(timestamp) {
        const date = new Date(timestamp);
        return `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}:${date.getSeconds().toString().padStart(2, '0')}`;
    }
    
    /**
     * 安全地从localStorage读取数据
     */
    getStoredData(key) {
        try {
            const data = localStorage.getItem(key);
            if (!data) return null;
            
            // 尝试解析JSON
            try {
                return JSON.parse(data);
            } catch (e) {
                // 如果不是JSON，直接返回字符串
                return data;
            }
        } catch (e) {
            console.error(`读取本地存储失败 [${key}]:`, e);
            return null;
        }
    }
    
    /**
     * 安全地保存数据到localStorage
     * 包含容量检查和自动清理机制
     */
    setStoredData(key, data) {
        try {
            // 估算数据大小（粗略）
            const dataStr = typeof data === 'object' ? JSON.stringify(data) : String(data);
            
            // 如果数据过大（超过4.5MB），尝试清理或拒绝
            if (dataStr.length > 4.5 * 1024 * 1024) {
                console.warn(`数据过大 (${(dataStr.length/1024/1024).toFixed(2)}MB)，尝试压缩...`);
                
                // 如果是背景图片或头像等base64数据，可能太大
                if (key.includes('background') || key.includes('avatar') || key.includes('sticker') || key.includes('music')) {
                    // 对于图片数据，限制大小
                    console.warn('图片数据过大，跳过保存');
                    return false;
                }
            }
            
            // 尝试保存
            if (typeof data === 'object') {
                localStorage.setItem(key, JSON.stringify(data));
            } else {
                localStorage.setItem(key, data);
            }
            
            return true;
            
        } catch (e) {
            console.error(`保存到本地存储失败 [${key}]:`, e);
            
            // 如果是配额超限错误
            if (e.name === 'QuotaExceededError') {
                console.warn('存储空间不足，尝试清理旧数据...');
                this.clearOldData();
                
                // 清理后重试一次
                try {
                    if (typeof data === 'object') {
                        localStorage.setItem(key, JSON.stringify(data));
                    } else {
                        localStorage.setItem(key, data);
                    }
                    console.log('重试保存成功');
                    return true;
                } catch (e2) {
                    console.error('重试保存仍然失败:', e2);
                    return false;
                }
            }
            
            return false;
        }
    }
    
    /**
     * 清理旧数据 - 只在空间不足时调用
     */
    clearOldData() {
        try {
            // 获取所有相关的存储键
            const allKeys = Object.keys(localStorage);
            const relevantKeys = allKeys.filter(key => 
                key.includes('seven_and_wish_') && 
                !key.includes(this.SELF_INFO_KEY) && 
                !key.includes(this.OTHER_INFO_KEY) &&
                !key.includes(this.MESSAGES_KEY)
            );
            
            // 按重要性排序并删除不重要的数据
            const priorityOrder = [
                this.DRAWN_CARDS_KEY,      // 塔罗牌记录（可以重置）
                this.READ_NO_REPLY_KEY,    // 已读不回记录（可以重置）
                this.TODAY_DATE_KEY,       // 今日日期（可以重置）
                this.LOVE_DAYS_KEY,        // 恋爱天数（可以重新计算）
                this.STICKERS_KEY,         // 表情包（占用空间大，优先清理）
                this.MUSIC_SETTINGS_KEY,   // 音乐文件（占用空间大）
            ];
            
            // 先清理优先级低的
            for (const key of priorityOrder) {
                if (localStorage.getItem(key)) {
                    localStorage.removeItem(key);
                    console.log(`已清理旧数据: ${key}`);
                    break; // 一次只清理一个，避免删除过多
                }
            }
        } catch (e) {
            console.error('清理旧数据失败:', e);
        }
    }
    
    // ========================
    // 各个数据模块的存取方法
    // ========================
    
    // ---- 用户信息 ----
    getSelfInfo() {
        return this.getStoredData(this.SELF_INFO_KEY) || {
            nickname: '我',
            avatar: null,
            status: '在线'
        };
    }
    
    saveSelfInfo(data) {
        return this.setStoredData(this.SELF_INFO_KEY, data);
    }
    
    getOtherInfo() {
        return this.getStoredData(this.OTHER_INFO_KEY) || {
            nickname: '对方',
            avatar: null,
            status: '在DR',
            mood: 85
        };
    }
    
    saveOtherInfo(data) {
        return this.setStoredData(this.OTHER_INFO_KEY, data);
    }
    
    // ---- 消息记录 ----
    getMessages() {
        return this.getStoredData(this.MESSAGES_KEY) || [];
    }
    
    saveMessage(message) {
        const messages = this.getMessages();
        messages.push(message);
        
        // 限制消息数量
        if (messages.length > this.MAX_MESSAGES) {
            const removedCount = messages.length - this.MAX_MESSAGES;
            messages.splice(0, removedCount);
        }
        
        return this.setStoredData(this.MESSAGES_KEY, messages);
    }
    
    saveAllMessages(messages) {
        // 限制消息数量
        if (messages.length > this.MAX_MESSAGES) {
            messages = messages.slice(-this.MAX_MESSAGES);
        }
        return this.setStoredData(this.MESSAGES_KEY, messages);
    }
    
    deleteMessage(messageId) {
        const messages = this.getMessages();
        const filtered = messages.filter(msg => msg.id !== messageId);
        
        if (filtered.length < messages.length) {
            return this.setStoredData(this.MESSAGES_KEY, filtered);
        }
        return false;
    }
    
    getMessageById(messageId) {
        const messages = this.getMessages();
        return messages.find(msg => msg.id === messageId) || null;
    }
    
    // ---- 回复词条 ----
    getPhrases() {
        return this.getStoredData(this.PHRASES_KEY) || [];
    }
    
    savePhrases(phrases) {
        return this.setStoredData(this.PHRASES_KEY, phrases);
    }
    
    // ---- 表情包 ----
    getStickers() {
        return this.getStoredData(this.STICKERS_KEY) || [];
    }
    
    saveStickers(stickers) {
        return this.setStoredData(this.STICKERS_KEY, stickers);
    }
    
    // ---- 发送设置 ----
    getSendSettings() {
        return this.getStoredData(this.SEND_SETTINGS_KEY) || {
            stickerRatio: 50,
            phraseRatio: 50,
            maxMessageCount: 3,
            autoSendFrequency: 600000
        };
    }
    
    saveSendSettings(settings) {
        return this.setStoredData(this.SEND_SETTINGS_KEY, settings);
    }
    
    // ---- 外观设置 ----
    getAppearanceSettings() {
        const data = this.getStoredData(this.APPEARANCE_KEY);
        if (data && data.loveStartDate) {
            // 恢复Date对象
            data.loveStartDate = new Date(data.loveStartDate);
        }
        return data || {
            appTitle: '梦角爱人',
            appSubtitle: '绝对私密的一对一聊天空间',
            loveStartDate: new Date(2024, 0, 1),
            moodChangeFrequency: 600000
        };
    }
    
    saveAppearanceSettings(settings) {
        // 保存时把Date转成ISO字符串
        const dataToSave = {
            ...settings,
            loveStartDate: settings.loveStartDate instanceof Date 
                ? settings.loveStartDate.toISOString() 
                : settings.loveStartDate
        };
        return this.setStoredData(this.APPEARANCE_KEY, dataToSave);
    }
    
    // ---- 背景设置 ----
    getBackgroundSettings() {
        return this.getStoredData(this.BACKGROUND_KEY) || {
            backgroundImage: null,
            opacity: 100
        };
    }
    
    saveBackgroundSettings(settings) {
        return this.setStoredData(this.BACKGROUND_KEY, settings);
    }
    
    // ---- 塔罗牌设置 ----
    getTarotSettings() {
        return this.getStoredData(this.TAROT_KEY) || {
            enabled: false,
            drawCount: 1,
            customPhrases: []
        };
    }
    
    saveTarotSettings(settings) {
        return this.setStoredData(this.TAROT_KEY, settings);
    }
    
    // ---- 已抽取塔罗牌记录（Set） ----
    getDrawnCards() {
        const cards = this.getStoredData(this.DRAWN_CARDS_KEY) || [];
        // 从数组恢复为Set
        return new Set(cards);
    }
    
    saveDrawnCards(cardSet) {
        // 将Set转换为数组存储
        const cardsArray = Array.from(cardSet);
        return this.setStoredData(this.DRAWN_CARDS_KEY, cardsArray);
    }
    
    // ---- 通信设置 ----
    getCommunicationSettings() {
        return this.getStoredData(this.COMMUNICATION_KEY) || {
            autoAcceptCalls: true,
            autoAcceptVideos: true,
            todayCalls: 0,
            todayVideos: 0,
            totalCallTime: 0,
            totalVideoTime: 0,
            todayIncomingCalls: 0,
            activeCallSettings: {
                enabled: true,
                overallFrequency: 30,
                callPreference: 50,
                presetMode: 'custom',
                minInterval: 15,
                maxInterval: 45,
                respectBusyStatus: true,
                timeSensitivity: true,
                adaptToActivity: true
            }
        };
    }
    
    saveCommunicationSettings(settings) {
        return this.setStoredData(this.COMMUNICATION_KEY, settings);
    }
    
    // ---- 音乐设置 ----
    getMusicSettings() {
        return this.getStoredData(this.MUSIC_SETTINGS_KEY) || {
            musicList: [],           // 音乐文件列表
            autoPlayMusic: true,    // 自动播放
            musicFrequency: 30,     // 播放频率
            playMode: 'random'      // 播放模式: random/single/list
        };
    }
    
    saveMusicSettings(settings) {
        return this.setStoredData(this.MUSIC_SETTINGS_KEY, settings);
    }
    
    // ---- 恋爱天数 ----
    getLoveDays() {
        return this.getStoredData(this.LOVE_DAYS_KEY) || 1;
    }
    
    saveLoveDays(days) {
        return this.setStoredData(this.LOVE_DAYS_KEY, days);
    }
    
    // ---- 已读不回记录 ----
    getReadNoReplyIds() {
        return this.getStoredData(this.READ_NO_REPLY_KEY) || [];
    }
    
    saveReadNoReplyIds(ids) {
        return this.setStoredData(this.READ_NO_REPLY_KEY, ids);
    }
    
    // ---- 今日日期 ----
    getTodayDate() {
        return this.getStoredData(this.TODAY_DATE_KEY) || new Date().toDateString();
    }
    
    saveTodayDate(dateStr) {
        return this.setStoredData(this.TODAY_DATE_KEY, dateStr);
    }
    
    /**
     * 清除所有数据（用于重置功能）
     */
    clearAllData() {
        try {
            // 获取所有相关键
            const keysToRemove = Object.keys(localStorage).filter(key => 
                key.includes('seven_and_wish_')
            );
            
            keysToRemove.forEach(key => {
                localStorage.removeItem(key);
            });
            
            // 重新创建默认数据
            this.createDefaultData();
            
            return true;
        } catch (e) {
            console.error('清除所有数据失败:', e);
            return false;
        }
    }
}

// ========================
// 第二部分：应用主类 - 整合存储逻辑，删除所有重置问题
// ========================

class ChatApp {
    constructor() {
        // 初始化数据管理器
        this.dataManager = new ChatDataManager();
        
        // 应用数据 - 所有数据都从dataManager加载，不在这里定义默认值
        this.appData = {
            // 这些属性会在loadAllData()中从localStorage加载
            selfInfo: null,
            otherInfo: null,
            messages: null,
            responsePhrases: null,
            stickers: null,
            sendSettings: null,
            appearanceSettings: null,
            backgroundSettings: null,
            tarotSettings: null,
            communicationSettings: null,
            musicSettings: null,
            drawnCards: null,
            loveDays: null,
            readNoReplyMessageIds: null,
            todayDate: null,
            
            // 运行时状态（不保存）
            isTyping: false,
            waitingForReply: false,
            quotedMessage: null,
            activeCall: null,
            activeVideo: null,
            callTimer: null,
            callStartTime: null,
            activeMessageActions: null,
            statusTimer: null,
            moodTimer: null,
            autoSendTimer: null,
            activeCallTimer: null,
            musicTimer: null,
            activeMusicPlayer: null,
            musicAudio: null,
            isMusicPlaying: false,
            currentPlayingMusic: null,
            musicCurrentTime: 0,
            editingUserType: null
        };
        
        // 常量定义
        this.DEFAULT_TAROT_CARDS = [
            "愚人 正位", "愚人 逆位", "魔术师 正位", "魔术师 逆位",
            "女祭司 正位", "女祭司 逆位", "女皇 正位", "女皇 逆位",
            "皇帝 正位", "皇帝 逆位", "教皇 正位", "教皇 逆位",
            "恋人 正位", "恋人 逆位", "战车 正位", "战车 逆位",
            "力量 正位", "力量 逆位", "隐士 正位", "隐士 逆位",
            "命运之轮 正位", "命运之轮 逆位", "正义 正位", "正义 逆位",
            "倒吊人 正位", "倒吊人 逆位", "死神 正位", "死神 逆位",
            "节制 正位", "节制 逆位", "恶魔 正位", "恶魔 逆位",
            "高塔 正位", "高塔 逆位", "星星 正位", "星星 逆位",
            "月亮 正位", "月亮 逆位", "太阳 正位", "太阳 逆位",
            "审判 正位", "审判 逆位", "世界 正位", "世界 逆位",
            "权杖一 正位", "权杖一 逆位", "权杖二 正位", "权杖二 逆位",
            "权杖三 正位", "权杖三 逆位", "权杖四 正位", "权杖四 逆位",
            "权杖五 正位", "权杖五 逆位", "权杖六 正位", "权杖六 逆位",
            "权杖七 正位", "权杖七 逆位", "权杖八 正位", "权杖八 逆位",
            "权杖九 正位", "权杖九 逆位", "权杖十 正位", "权杖十 逆位",
            "权杖侍从 正位", "权杖侍从 逆位", "权杖骑士 正位", "权杖骑士 逆位",
            "权杖皇后 正位", "权杖皇后 逆位", "权杖国王 正位", "权杖国王 逆位",
            "圣杯一 正位", "圣杯一 逆位", "圣杯二 正位", "圣杯二 逆位",
            "圣杯三 正位", "圣杯三 逆位", "圣杯四 正位", "圣杯四 逆位",
            "圣杯五 正位", "圣杯五 逆位", "圣杯六 正位", "圣杯六 逆位",
            "圣杯七 正位", "圣杯七 逆位", "圣杯八 正位", "圣杯八 逆位",
            "圣杯九 正位", "圣杯九 逆位", "圣杯十 正位", "圣杯十 逆位",
            "圣杯侍从 正位", "圣杯侍从 逆位", "圣杯骑士 正位", "圣杯骑士 逆位",
            "圣杯皇后 正位", "圣杯皇后 逆位", "圣杯国王 正位", "圣杯国王 逆位",
            "宝剑一 正位", "宝剑一 逆位", "宝剑二 正位", "宝剑二 逆位",
            "宝剑三 正位", "宝剑三 逆位", "宝剑四 正位", "宝剑四 逆位",
            "宝剑五 正位", "宝剑五 逆位", "宝剑六 正位", "宝剑六 逆位",
            "宝剑七 正位", "宝剑七 逆位", "宝剑八 正位", "宝剑八 逆位",
            "宝剑九 正位", "宝剑九 逆位", "宝剑十 正位", "宝剑十 逆位",
            "宝剑侍从 正位", "宝剑侍从 逆位", "宝剑骑士 正位", "宝剑骑士 逆位",
            "宝剑皇后 正位", "宝剑皇后 逆位", "宝剑国王 正位", "宝剑国王 逆位",
            "星币一 正位", "星币一 逆位", "星币二 正位", "星币二 逆位",
            "星币三 正位", "星币三 逆位", "星币四 正位", "星币四 逆位",
            "星币五 正位", "星币五 逆位", "星币六 正位", "星币六 逆位",
            "星币七 正位", "星币七 逆位", "星币八 正位", "星币八 逆位",
            "星币九 正位", "星币九 逆位", "星币十 正位", "星币十 逆位",
            "星币侍从 正位", "星币侍从 逆位", "星币骑士 正位", "星币骑士 逆位",
            "星币皇后 正位", "星币皇后 逆位", "星币国王 正位", "星币国王 逆位"
        ];
        
        this.PRESET_MODES = {
            quiet: { name: '安静模式', overallFrequency: 10, callPreference: 30, minInterval: 45, maxInterval: 120 },
            daily: { name: '日常模式', overallFrequency: 30, callPreference: 50, minInterval: 20, maxInterval: 60 },
            intimate: { name: '亲密模式', overallFrequency: 50, callPreference: 70, minInterval: 10, maxInterval: 30 },
            custom: { name: '自定义' }
        };
        
        // 状态选项
        this.statusOptions = [
            { text: '在DR', class: 'dr', color: '#2196f3' },
            { text: '在CR', class: 'cr', color: '#9c27b0' },
            { text: '在线', class: 'online', color: '#4caf50' },
            { text: '在忙', class: 'busy', color: '#ff9800' },
            { text: '在我身边', class: 'nearby', color: '#ff5722' }
        ];
        
        // 状态切换时间
        this.statusChangeTimes = [120, 300, 600, 900, 1800, 2700, 3600, 5400, 7200];
        
        // 启动应用
        this.init();
    }
    
    /**
     * 从localStorage加载所有数据
     * 关键改进：只加载，不重置，不覆盖已有数据
     */
    loadAllData() {
        console.log('从本地存储加载数据...');
        
        // 加载用户信息
        this.appData.selfInfo = this.dataManager.getSelfInfo();
        this.appData.otherInfo = this.dataManager.getOtherInfo();
        
        // 加载消息记录
        this.appData.messages = this.dataManager.getMessages();
        
        // 加载回复词条
        this.appData.responsePhrases = this.dataManager.getPhrases();
        
        // 加载表情包
        this.appData.stickers = this.dataManager.getStickers();
        
        // 加载发送设置
        this.appData.sendSettings = this.dataManager.getSendSettings();
        
        // 加载外观设置
        this.appData.appearanceSettings = this.dataManager.getAppearanceSettings();
        
        // 加载背景设置
        this.appData.backgroundSettings = this.dataManager.getBackgroundSettings();
        
        // 加载塔罗牌设置
        this.appData.tarotSettings = this.dataManager.getTarotSettings();
        
        // 加载通信设置
        this.appData.communicationSettings = this.dataManager.getCommunicationSettings();
        
        // 加载音乐设置
        this.appData.musicSettings = this.dataManager.getMusicSettings();
        
        // 加载已抽取塔罗牌记录（Set）
        this.appData.drawnCards = this.dataManager.getDrawnCards();
        
        // 加载恋爱天数
        this.appData.loveDays = this.dataManager.getLoveDays();
        
        // 加载已读不回记录
        this.appData.readNoReplyMessageIds = this.dataManager.getReadNoReplyIds();
        
        // 加载今日日期
        this.appData.todayDate = this.dataManager.getTodayDate();
        
        // 检查是否需要重置每日统计
        this.checkResetDailyStats();
        
        // 计算恋爱天数
        this.calculateLoveDays();
        
        console.log('数据加载完成:', {
            消息数量: this.appData.messages.length,
            表情包数量: this.appData.stickers.length,
            词条数量: this.appData.responsePhrases.length,
            塔罗牌字卡: this.appData.tarotSettings.customPhrases.length,
            塔罗牌模式: this.appData.tarotSettings.enabled ? '开启' : '关闭',
            音乐数量: this.appData.musicSettings?.musicList?.length || 0
        });
    }
    
    /**
     * 保存所有数据到localStorage
     */
    saveAllData() {
        // 保存用户信息
        this.dataManager.saveSelfInfo(this.appData.selfInfo);
        this.dataManager.saveOtherInfo(this.appData.otherInfo);
        
        // 保存消息记录
        this.dataManager.saveAllMessages(this.appData.messages);
        
        // 保存回复词条
        this.dataManager.savePhrases(this.appData.responsePhrases);
        
        // 保存表情包
        this.dataManager.saveStickers(this.appData.stickers);
        
        // 保存发送设置
        this.dataManager.saveSendSettings(this.appData.sendSettings);
        
        // 保存外观设置
        this.dataManager.saveAppearanceSettings(this.appData.appearanceSettings);
        
        // 保存背景设置
        this.dataManager.saveBackgroundSettings(this.appData.backgroundSettings);
        
        // 保存塔罗牌设置
        this.dataManager.saveTarotSettings(this.appData.tarotSettings);
        
        // 保存通信设置
        this.dataManager.saveCommunicationSettings(this.appData.communicationSettings);
        
        // 保存音乐设置
        this.dataManager.saveMusicSettings(this.appData.musicSettings);
        
        // 保存已抽取塔罗牌记录
        this.dataManager.saveDrawnCards(this.appData.drawnCards);
        
        // 保存恋爱天数
        this.dataManager.saveLoveDays(this.appData.loveDays);
        
        // 保存已读不回记录
        this.dataManager.saveReadNoReplyIds(this.appData.readNoReplyMessageIds);
        
        // 保存今日日期
        this.dataManager.saveTodayDate(this.appData.todayDate);
    }
    
    /**
     * 检查是否需要重置每日统计
     */
    checkResetDailyStats() {
        const currentDate = new Date().toDateString();
        if (this.appData.todayDate !== currentDate) {
            // 新的一天，重置每日统计
            this.appData.communicationSettings.todayCalls = 0;
            this.appData.communicationSettings.todayVideos = 0;
            this.appData.communicationSettings.todayIncomingCalls = 0;
            this.appData.todayDate = currentDate;
            console.log('已重置每日通话统计');
        }
    }
    
    /**
     * 计算恋爱天数
     */
    calculateLoveDays() {
        const today = new Date();
        const startDate = this.appData.appearanceSettings.loveStartDate;
        
        if (startDate && startDate instanceof Date) {
            const timeDiff = today.getTime() - startDate.getTime();
            this.appData.loveDays = Math.floor(timeDiff / (1000 * 3600 * 24)) + 1;
            if (this.appData.loveDays < 1) this.appData.loveDays = 1;
        }
    }
    
    /**
     * 初始化应用
     */
    init() {
        console.log('初始化应用...');
        
        // 1. 加载所有数据（最关键的一步）
        this.loadAllData();
        
        // 2. 打开页面时将所有对方发送的消息标记为已读
        this.markOtherMessagesAsRead();
        
        // 3. 渲染所有UI
        this.renderAllUI();
        
        // 4. 启动所有定时器
        this.startAllTimers();
        
        // 5. 设置事件监听器
        this.setupEventListeners();
        
        // 6. 显示加载成功通知
        this.showNotification('聊天记录已加载');
        
        // 7. 自动保存定时器（每30秒）
        setInterval(() => {
            this.saveAllData();
        }, 30000);
        
        // 8. 页面关闭前保存
        window.addEventListener('beforeunload', () => {
            this.saveAllData();
        });
        
        // 9. 页面可见性变化时保存
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                this.saveAllData();
            }
        });
    }
    
    /**
     * 将所有对方发送的消息标记为已读
     */
    markOtherMessagesAsRead() {
        if (this.appData.messages) {
            this.appData.messages.forEach(msg => {
                if (msg.sender === 'other') {
                    msg.read = true;
                }
            });
        }
    }
    
    /**
     * 渲染所有UI
     */
    renderAllUI() {
        this.renderMessages();
        this.renderStickerPreview();
        this.renderPhrasesTextarea();
        this.renderTarotUI();
        this.renderBackgroundUI();
        this.renderUserInfo();
        this.renderAppearance();
        this.renderCommunicationStats();
        this.initSendSettingsUI();
        this.initAppearanceSettingsUI();
        this.initCommunicationSettingsUI();
        this.initActiveCallSettingsUI();
        this.initMusicSettingsUI();
        
        this.updateStickerCount();
        this.updatePhraseCount();
        this.updateTarotPhraseCount();
    }
    
    // ========================
    // UI 渲染方法（保留原文件的实现）
    // ========================
    
    renderMessages() {
        const messagesArea = document.getElementById('messagesArea');
        if (!messagesArea) return;
        
        messagesArea.innerHTML = '';
        
        // 添加"对方正在输入"指示器
        const typingIndicator = document.getElementById('typingIndicator');
        if (typingIndicator) {
            messagesArea.appendChild(typingIndicator);
            typingIndicator.classList.toggle('active', this.appData.isTyping);
        }
        
        // 如果没有消息，显示提示
        if (!this.appData.messages || this.appData.messages.length === 0) {
            const emptyMessage = document.createElement('div');
            emptyMessage.className = 'message other';
            emptyMessage.innerHTML = `
                还没有聊天记录，开始聊天吧！
                <div class="message-time">
                    <span>${this.getCurrentTime()}</span>
                </div>
            `;
            messagesArea.appendChild(emptyMessage);
        } else {
            // 渲染所有消息
            this.appData.messages.forEach(msg => {
                const messageContainer = document.createElement('div');
                messageContainer.className = `message-container ${msg.sender}`;
                
                // 头像
                const messageAvatar = document.createElement('div');
                messageAvatar.className = 'message-avatar';
                
                const avatarInfo = msg.sender === 'self' ? this.appData.selfInfo : this.appData.otherInfo;
                if (avatarInfo && avatarInfo.avatar) {
                    messageAvatar.innerHTML = `<img src="${avatarInfo.avatar}" alt="${avatarInfo.nickname}">`;
                } else {
                    messageAvatar.innerHTML = `<span></span>`;
                }
                
                // 消息内容
                const messageContent = document.createElement('div');
                messageContent.className = 'message-content';
                
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${msg.sender}`;
                
                // 创建消息操作菜单
                const messageActions = document.createElement('div');
                messageActions.className = 'message-actions';
                messageActions.innerHTML = `
                    <button class="message-action-btn quote" data-id="${msg.id}">引用</button>
                    <button class="message-action-btn delete" data-id="${msg.id}">删除</button>
                    ${msg.sender === 'self' ? '<button class="message-action-btn recall" data-id="${msg.id}">撤回</button>' : ''}
                `;
                
                // 添加点击事件用于显示操作菜单
                messageDiv.addEventListener('click', (e) => {
                    e.stopPropagation();
                    
                    if (this.appData.activeMessageActions && this.appData.activeMessageActions !== messageActions) {
                        this.appData.activeMessageActions.style.display = 'none';
                    }
                    
                    if (messageActions.style.display === 'flex') {
                        messageActions.style.display = 'none';
                        this.appData.activeMessageActions = null;
                    } else {
                        messageActions.style.display = 'flex';
                        this.appData.activeMessageActions = messageActions;
                    }
                });
                
                // 检查是否为通话/视频消息
                const isCallMessage = msg.type === 'call' || msg.type === 'video';
                const isTarotMessage = msg.isTarot;
                const isMusicMessage = msg.type === 'music';
                
                if (isCallMessage) {
                    messageDiv.classList.add(`${msg.type}-message`);
                } else if (isTarotMessage) {
                    messageDiv.classList.add('tarot-message');
                } else if (isMusicMessage) {
                    messageDiv.classList.add('call-message');
                }
                
                // 检查是否为已读不回消息
                const isReadNoReply = msg.id && this.appData.readNoReplyMessageIds && 
                                      this.appData.readNoReplyMessageIds.includes(msg.id);
                
                // 如果有引用消息，显示引用
                let quotedContent = '';
                if (msg.quotedMessage) {
                    const quoted = msg.quotedMessage;
                    quotedContent = `
                        <div class="quoted-message" data-id="${quoted.id}">
                            ${quoted.isSticker ? 
                              `<img src="${quoted.stickerData}" alt="表情包" style="max-height:20px;">` : 
                              quoted.text || ''}
                        </div>
                    `;
                }
                
                // 塔罗牌消息添加图标
                let tarotIcon = '';
                if (isTarotMessage) {
                    tarotIcon = '🔮 ';
                }
                
                // 音乐消息添加图标
                let musicIcon = '';
                if (isMusicMessage) {
                    musicIcon = '🎵 ';
                }
                
                // 如果是表情包，显示图片
                if (msg.isSticker && msg.stickerData) {
                    messageDiv.innerHTML = `
                        ${quotedContent}
                        <img src="${msg.stickerData}" alt="表情包" style="max-width: 100px; border-radius: 6px;">
                        <div class="message-time">
                            <span>${msg.time || ''}</span>
                            <span class="message-status">
                                <span class="status-check ${msg.read ? 'double' : 'single'}">${msg.read ? '✓✓' : '✓'}</span>
                                <span>${msg.read ? '已读' : '未读'}</span>
                                ${isReadNoReply ? '<span class="read-no-reply">👀 已读不回</span>' : ''}
                            </span>
                        </div>
                    `;
                } else if (isCallMessage) {
                    messageDiv.innerHTML = `
                        <div style="display:flex; align-items:center; gap:8px;">
                            <i class="material-icons" style="font-size:1.2rem;">${msg.type === 'call' ? 'call' : 'videocam'}</i>
                            <div>
                                <div style="font-weight:500;">${msg.title || ''}</div>
                                <div style="font-size:0.8rem;">${msg.duration || ''}</div>
                            </div>
                        </div>
                        <div class="message-time">
                            <span>${msg.time || ''}</span>
                            <span class="message-status">
                                <span class="status-check double">✓✓</span>
                                <span>已读</span>
                            </span>
                        </div>
                    `;
                } else {
                    messageDiv.innerHTML = `
                        ${quotedContent}
                        ${tarotIcon}${musicIcon}${msg.text || ''}
                        <div class="message-time">
                            <span>${msg.time || ''}</span>
                            <span class="message-status">
                                <span class="status-check ${msg.read ? 'double' : 'single'}">${msg.read ? '✓✓' : '✓'}</span>
                                <span>${msg.read ? '已读' : '未读'}</span>
                                ${isReadNoReply ? '<span class="read-no-reply">👀 已读不回</span>' : ''}
                            </span>
                        </div>
                    `;
                }
                
                messageContent.appendChild(messageDiv);
                messageContent.appendChild(messageActions);
                messageContainer.appendChild(messageAvatar);
                messageContainer.appendChild(messageContent);
                messagesArea.appendChild(messageContainer);
                
                // 为操作菜单按钮添加事件监听器
                const quoteBtn = messageActions.querySelector('.message-action-btn.quote');
                if (quoteBtn) {
                    quoteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.quoteMessage(msg);
                        messageActions.style.display = 'none';
                        this.appData.activeMessageActions = null;
                    });
                }
                
                const deleteBtn = messageActions.querySelector('.message-action-btn.delete');
                if (deleteBtn) {
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.deleteMessage(msg.id);
                        messageActions.style.display = 'none';
                        this.appData.activeMessageActions = null;
                    });
                }
                
                const recallBtn = messageActions.querySelector('.message-action-btn.recall');
                if (recallBtn) {
                    recallBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.recallMessage(msg.id);
                        messageActions.style.display = 'none';
                        this.appData.activeMessageActions = null;
                    });
                }
            });
        }
        
        // 滚动到底部
        messagesArea.scrollTop = messagesArea.scrollHeight;
    }
    
    renderStickerPreview() {
        const stickerPreview = document.getElementById('stickerPreview');
        if (!stickerPreview) return;
        
        stickerPreview.innerHTML = '';
        
        // 添加已有的表情包
        if (this.appData.stickers) {
            this.appData.stickers.forEach(sticker => {
                const stickerItem = document.createElement('div');
                stickerItem.className = 'sticker-item';
                stickerItem.innerHTML = `
                    <img src="${sticker.data}" alt="表情包">
                    <button class="delete-sticker" data-id="${sticker.id}">×</button>
                `;
                
                stickerItem.querySelector('.delete-sticker').addEventListener('click', (e) => {
                    e.stopPropagation();
                    const id = sticker.id;
                    this.appData.stickers = this.appData.stickers.filter(s => s.id !== id);
                    this.renderStickerPreview();
                    this.saveAllData();
                    this.showNotification('表情包已删除');
                });
                
                stickerPreview.appendChild(stickerItem);
            });
        }
        
        // 添加添加按钮
        const addButton = document.createElement('div');
        addButton.className = 'sticker-item';
        addButton.id = 'addStickerPlaceholder';
        addButton.innerHTML = '<div class="sticker-placeholder">+</div>';
        addButton.addEventListener('click', () => document.getElementById('stickerUpload')?.click());
        stickerPreview.appendChild(addButton);
        
        this.updateStickerCount();
    }
    
    renderPhrasesTextarea() {
        const textarea = document.getElementById('phrasesTextarea');
        if (textarea && this.appData.responsePhrases) {
            textarea.value = this.appData.responsePhrases.join('\n');
            this.updatePhraseCount();
        }
    }
    
    renderTarotUI() {
        // 设置开关状态
        const tarotModeToggle = document.getElementById('tarotModeToggle');
        if (tarotModeToggle) {
            tarotModeToggle.checked = this.appData.tarotSettings?.enabled || false;
        }
        
        // 设置抽取数量
        const tarotCountValue = document.getElementById('tarotCountValue');
        if (tarotCountValue) {
            tarotCountValue.textContent = this.appData.tarotSettings?.drawCount || 1;
        }
        
        // 生成数字选择器
        const tarotNumberSelector = document.getElementById('tarotNumberSelector');
        if (tarotNumberSelector) {
            tarotNumberSelector.innerHTML = '';
            for (let i = 1; i <= 15; i++) {
                const numberDiv = document.createElement('div');
                numberDiv.className = `tarot-number ${i === (this.appData.tarotSettings?.drawCount || 1) ? 'active' : ''}`;
                numberDiv.textContent = i;
                numberDiv.dataset.number = i;
                numberDiv.addEventListener('click', () => this.selectTarotNumber(i));
                tarotNumberSelector.appendChild(numberDiv);
            }
        }
        
        // 设置字卡内容
        const tarotTextarea = document.getElementById('tarotTextarea');
        if (tarotTextarea && this.appData.tarotSettings?.customPhrases) {
            tarotTextarea.value = this.appData.tarotSettings.customPhrases.join('\n');
        }
        
        // 更新计数和状态
        this.updateTarotPhraseCount();
        this.updateTarotStatus();
    }
    
    renderBackgroundUI() {
        this.updateBackgroundPreview();
        
        const slider = document.getElementById('backgroundOpacitySlider');
        const value = document.getElementById('backgroundOpacityValue');
        if (slider && value && this.appData.backgroundSettings) {
            slider.value = this.appData.backgroundSettings.opacity || 100;
            value.textContent = `${this.appData.backgroundSettings.opacity || 100}%`;
        }
        
        this.applyBackgroundSettings();
    }
    
    renderUserInfo() {
        // 自己
        const selfAvatar = document.getElementById('selfAvatar');
        if (selfAvatar) {
            if (this.appData.selfInfo?.avatar) {
                selfAvatar.innerHTML = `<img src="${this.appData.selfInfo.avatar}" alt="${this.appData.selfInfo.nickname}">`;
            } else {
                selfAvatar.innerHTML = `<span></span>`;
            }
        }
        
        const selfNickname = document.getElementById('selfNickname');
        if (selfNickname) {
            selfNickname.textContent = this.appData.selfInfo?.nickname || '我';
        }
        
        const selfStatusText = document.getElementById('selfStatusText');
        if (selfStatusText) {
            selfStatusText.textContent = this.appData.selfInfo?.status || '在线';
        }
        
        // 对方
        const otherAvatar = document.getElementById('otherAvatar');
        if (otherAvatar) {
            if (this.appData.otherInfo?.avatar) {
                otherAvatar.innerHTML = `<img src="${this.appData.otherInfo.avatar}" alt="${this.appData.otherInfo.nickname}">`;
            } else {
                otherAvatar.innerHTML = `<span></span>`;
            }
        }
        
        const otherNickname = document.getElementById('otherNickname');
        if (otherNickname) {
            otherNickname.textContent = this.appData.otherInfo?.nickname || '对方';
        }
        
        const otherStatusText = document.getElementById('otherStatusText');
        if (otherStatusText) {
            otherStatusText.textContent = this.appData.otherInfo?.status || '在DR';
        }
        
        const otherMoodValue = document.getElementById('otherMoodValue');
        if (otherMoodValue) {
            otherMoodValue.textContent = `${this.appData.otherInfo?.mood || 85}%`;
        }
        
        this.updateOtherStatusIndicator();
    }
    
    renderAppearance() {
        const appTitle = document.getElementById('appTitle');
        if (appTitle) {
            appTitle.textContent = this.appData.appearanceSettings?.appTitle || '梦角爱人';
        }
        
        const appSubtitle = document.getElementById('appSubtitle');
        if (appSubtitle) {
            appSubtitle.textContent = this.appData.appearanceSettings?.appSubtitle || '绝对私密的一对一聊天空间';
        }
        
        const loveDaysCount = document.getElementById('loveDaysCount');
        if (loveDaysCount) {
            loveDaysCount.textContent = `恋爱第 ${this.appData.loveDays || 1} 天`;
        }
    }
    
    renderCommunicationStats() {
        const todayCalls = document.getElementById('todayCalls');
        if (todayCalls) {
            todayCalls.textContent = this.appData.communicationSettings?.todayCalls || 0;
        }
        
        const totalCallTime = document.getElementById('totalCallTime');
        if (totalCallTime) {
            totalCallTime.textContent = this.appData.communicationSettings?.totalCallTime || 0;
        }
        
        const todayVideos = document.getElementById('todayVideos');
        if (todayVideos) {
            todayVideos.textContent = this.appData.communicationSettings?.todayVideos || 0;
        }
        
        const totalVideoTime = document.getElementById('totalVideoTime');
        if (totalVideoTime) {
            totalVideoTime.textContent = this.appData.communicationSettings?.totalVideoTime || 0;
        }
        
        const todayIncomingCalls = document.getElementById('todayIncomingCalls');
        if (todayIncomingCalls) {
            todayIncomingCalls.textContent = this.appData.communicationSettings?.todayIncomingCalls || 0;
        }
    }
    
    initSendSettingsUI() {
        const stickerRatioSlider = document.getElementById('stickerRatioSlider');
        const phraseRatioSlider = document.getElementById('phraseRatioSlider');
        const stickerRatioValue = document.getElementById('stickerRatioValue');
        const phraseRatioValue = document.getElementById('phraseRatioValue');
        const maxMessageCount = document.getElementById('maxMessageCount');
        const autoSendFrequency = document.getElementById('autoSendFrequency');
        
        if (stickerRatioSlider && this.appData.sendSettings) {
            stickerRatioSlider.value = this.appData.sendSettings.stickerRatio || 50;
        }
        if (phraseRatioSlider && this.appData.sendSettings) {
            phraseRatioSlider.value = this.appData.sendSettings.phraseRatio || 50;
        }
        if (stickerRatioValue && this.appData.sendSettings) {
            stickerRatioValue.textContent = `${this.appData.sendSettings.stickerRatio || 50}%`;
        }
        if (phraseRatioValue && this.appData.sendSettings) {
            phraseRatioValue.textContent = `${this.appData.sendSettings.phraseRatio || 50}%`;
        }
        if (maxMessageCount && this.appData.sendSettings) {
            maxMessageCount.value = this.appData.sendSettings.maxMessageCount || 3;
        }
        if (autoSendFrequency && this.appData.sendSettings) {
            autoSendFrequency.value = this.appData.sendSettings.autoSendFrequency || 600000;
        }
    }
    
    initAppearanceSettingsUI() {
        const appTitleInput = document.getElementById('appTitleInput');
        const appSubtitleInput = document.getElementById('appSubtitleInput');
        const loveYear = document.getElementById('loveYear');
        const loveMonth = document.getElementById('loveMonth');
        const loveDay = document.getElementById('loveDay');
        const moodChangeFrequency = document.getElementById('moodChangeFrequency');
        
        if (appTitleInput && this.appData.appearanceSettings) {
            appTitleInput.value = this.appData.appearanceSettings.appTitle || '梦角爱人';
        }
        if (appSubtitleInput && this.appData.appearanceSettings) {
            appSubtitleInput.value = this.appData.appearanceSettings.appSubtitle || '绝对私密的一对一聊天空间';
        }
        
        if (this.appData.appearanceSettings?.loveStartDate) {
            const date = new Date(this.appData.appearanceSettings.loveStartDate);
            if (loveYear) loveYear.value = date.getFullYear();
            if (loveMonth) loveMonth.value = date.getMonth() + 1;
            if (loveDay) loveDay.value = date.getDate();
        }
        
        if (moodChangeFrequency && this.appData.appearanceSettings) {
            moodChangeFrequency.value = this.appData.appearanceSettings.moodChangeFrequency || 600000;
        }
    }
    
    initCommunicationSettingsUI() {
        const autoAcceptCalls = document.getElementById('autoAcceptCalls');
        const autoAcceptVideos = document.getElementById('autoAcceptVideos');
        
        if (autoAcceptCalls && this.appData.communicationSettings) {
            autoAcceptCalls.checked = this.appData.communicationSettings.autoAcceptCalls !== false;
        }
        if (autoAcceptVideos && this.appData.communicationSettings) {
            autoAcceptVideos.checked = this.appData.communicationSettings.autoAcceptVideos !== false;
        }
    }
    
    initActiveCallSettingsUI() {
        const overallFrequencySlider = document.getElementById('overallFrequencySlider');
        const callPreferenceSlider = document.getElementById('callPreferenceSlider');
        
        if (overallFrequencySlider && this.appData.communicationSettings?.activeCallSettings) {
            overallFrequencySlider.value = this.appData.communicationSettings.activeCallSettings.overallFrequency || 30;
            this.updateOverallFrequencyDisplay();
        }
        
        if (callPreferenceSlider && this.appData.communicationSettings?.activeCallSettings) {
            callPreferenceSlider.value = this.appData.communicationSettings.activeCallSettings.callPreference || 50;
            this.updateCallPreferenceDisplay();
        }
        
        this.updateActiveCallPreview();
        this.updatePresetButtons();
    }
    
    updateOtherStatusIndicator() {
        const indicator = document.getElementById('otherStatusIndicator');
        if (!indicator) return;
        
        indicator.className = 'status-indicator';
        
        const status = this.statusOptions.find(s => s.text === this.appData.otherInfo?.status);
        if (status) {
            indicator.classList.add(status.class);
            indicator.style.backgroundColor = status.color;
        }
    }
    
    updateStickerCount() {
        const countEl = document.getElementById('stickerCount');
        if (countEl) {
            countEl.textContent = this.appData.stickers?.length || 0;
        }
    }
    
    updatePhraseCount() {
        const textarea = document.getElementById('phrasesTextarea');
        const countEl = document.getElementById('phraseCount');
        
        if (textarea && countEl) {
            const text = textarea.value.trim();
            if (!text) {
                countEl.textContent = '0';
                return;
            }
            
            const phrases = text.split('\n')
                .map(p => p.trim())
                .filter(p => p.length > 0);
            countEl.textContent = phrases.length;
        }
    }
    
    updateTarotPhraseCount() {
        const countEl = document.getElementById('tarotPhraseCount');
        if (countEl && this.appData.tarotSettings) {
            countEl.textContent = this.appData.tarotSettings.customPhrases?.length || 0;
        }
    }
    
    updateTarotStatus() {
        const statusEl = document.getElementById('tarotStatus');
        if (!statusEl) return;
        
        const enabled = this.appData.tarotSettings?.enabled || false;
        const drawCount = this.appData.tarotSettings?.drawCount || 1;
        const count = this.appData.tarotSettings?.customPhrases?.length || 0;
        
        if (enabled) {
            statusEl.innerHTML = `
                <strong>塔罗牌梦占模式已开启 🔮</strong><br>
                对方将抽取 <strong>${drawCount}</strong> 张塔罗牌字卡进行回复<br>
                塔罗牌字卡库: <strong>${count}</strong> 张<br>
                <span style="font-size:0.75rem; opacity:0.8;">智能规则：同牌正逆位不重复抽取</span>
            `;
            statusEl.style.background = 'var(--tarot-bg)';
            statusEl.style.color = 'var(--tarot-text)';
            statusEl.style.borderLeft = '3px solid var(--tarot-text)';
        } else {
            statusEl.innerHTML = `
                <strong>塔罗牌梦占模式已关闭</strong><br>
                对方使用普通词条和表情包回复
            `;
            statusEl.style.background = 'rgba(255, 255, 255, 0.7)';
            statusEl.style.color = 'var(--text)';
            statusEl.style.borderLeft = '3px solid #ccc';
        }
    }
    
    updateBackgroundPreview() {
        const preview = document.getElementById('backgroundPreview');
        if (!preview) return;
        
        if (this.appData.backgroundSettings?.backgroundImage) {
            preview.innerHTML = `<img src="${this.appData.backgroundSettings.backgroundImage}" alt="背景预览">`;
            preview.style.backgroundImage = `url(${this.appData.backgroundSettings.backgroundImage})`;
            preview.style.backgroundSize = 'cover';
            preview.style.backgroundPosition = 'center';
        } else {
            preview.innerHTML = `
                <div class="empty">
                    <i class="material-icons">wallpaper</i>
                    <span>默认背景</span>
                </div>
            `;
        }
    }
    
    applyBackgroundSettings() {
        const container = document.getElementById('backgroundContainer');
        if (!container) return;
        
        if (this.appData.backgroundSettings?.backgroundImage) {
            container.style.backgroundImage = `url(${this.appData.backgroundSettings.backgroundImage})`;
            container.style.backgroundColor = 'transparent';
            container.style.opacity = (this.appData.backgroundSettings.opacity / 100).toString();
        } else {
            container.style.backgroundImage = 'none';
            container.style.backgroundColor = '';
            container.style.opacity = '1';
        }
    }
    
    updateOverallFrequencyDisplay() {
        const value = this.appData.communicationSettings?.activeCallSettings?.overallFrequency || 30;
        const el = document.getElementById('overallFrequencyValue');
        if (el) el.textContent = `${value}%`;
    }
    
    updateCallPreferenceDisplay() {
        const value = this.appData.communicationSettings?.activeCallSettings?.callPreference || 50;
        const el = document.getElementById('callPreferenceValue');
        if (el) {
            const callPercent = value;
            const videoPercent = 100 - value;
            el.textContent = `电话 ${callPercent}% / 视频 ${videoPercent}%`;
        }
    }
    
    updateActiveCallPreview() {
        const settings = this.appData.communicationSettings?.activeCallSettings;
        if (!settings) return;
        
        const frequency = settings.overallFrequency || 30;
        
        let frequencyDesc = '';
        if (frequency === 0) frequencyDesc = '关闭';
        else if (frequency <= 15) frequencyDesc = '很低';
        else if (frequency <= 30) frequencyDesc = '较低';
        else if (frequency <= 50) frequencyDesc = '中等';
        else if (frequency <= 75) frequencyDesc = '较高';
        else frequencyDesc = '很高';
        
        const previewFrequency = document.getElementById('previewFrequency');
        if (previewFrequency) previewFrequency.textContent = `${frequencyDesc} (${frequency}%)`;
        
        // 预计每天呼叫次数
        let dailyCalls = 0;
        if (frequency === 0) dailyCalls = 0;
        else if (frequency <= 15) dailyCalls = Math.floor(Math.random() * 2) + 1;
        else if (frequency <= 30) dailyCalls = Math.floor(Math.random() * 3) + 2;
        else if (frequency <= 50) dailyCalls = Math.floor(Math.random() * 4) + 3;
        else if (frequency <= 75) dailyCalls = Math.floor(Math.random() * 5) + 4;
        else dailyCalls = Math.floor(Math.random() * 6) + 5;
        
        const previewDaily = document.getElementById('previewDaily');
        if (previewDaily) previewDaily.textContent = frequency === 0 ? '无呼叫' : `${dailyCalls}次呼叫`;
    }
    
    updatePresetButtons() {
        const preset = this.appData.communicationSettings?.activeCallSettings?.presetMode || 'custom';
        const buttons = document.querySelectorAll('.preset-btn');
        
        buttons.forEach(btn => {
            const btnPreset = btn.getAttribute('data-preset');
            btn.classList.toggle('active', btnPreset === preset);
        });
    }
    
    // ========================
    // 定时器管理
    // ========================
    
    startAllTimers() {
        this.startStatusSwitching();
        this.startMoodChanging();
        this.startAutoSending();
        this.startActiveCallScheduler();
        this.startMusicScheduler();
    }
    
    startStatusSwitching() {
        if (this.appData.statusTimer) clearTimeout(this.appData.statusTimer);
        
        const switchStatus = () => {
            if (Math.random() > 0.3) {
                const timeIndex = Math.floor(Math.random() * this.statusChangeTimes.length);
                const nextTime = this.statusChangeTimes[timeIndex];
                this.appData.statusTimer = setTimeout(switchStatus, nextTime * 1000);
                return;
            }
            
            let newStatus;
            do {
                const randomIndex = Math.floor(Math.random() * this.statusOptions.length);
                newStatus = this.statusOptions[randomIndex];
            } while (newStatus.text === this.appData.otherInfo?.status);
            
            if (this.appData.otherInfo) {
                this.appData.otherInfo.status = newStatus.text;
                this.renderUserInfo();
                this.saveAllData();
            }
            
            const timeIndex = Math.floor(Math.random() * this.statusChangeTimes.length);
            const nextTime = this.statusChangeTimes[timeIndex];
            this.appData.statusTimer = setTimeout(switchStatus, nextTime * 1000);
        };
        
        setTimeout(switchStatus, 10000);
    }
    
    startMoodChanging() {
        if (this.appData.moodTimer) clearInterval(this.appData.moodTimer);
        
        const frequency = this.appData.appearanceSettings?.moodChangeFrequency || 600000;
        this.appData.moodTimer = setInterval(() => {
            if (this.appData.otherInfo) {
                const change = Math.floor(Math.random() * 21) - 10;
                this.appData.otherInfo.mood = Math.max(0, Math.min(100, (this.appData.otherInfo.mood || 85) + change));
                this.renderUserInfo();
                this.saveAllData();
            }
        }, frequency);
    }
    
    startAutoSending() {
        if (this.appData.autoSendTimer) clearInterval(this.appData.autoSendTimer);
        
        const frequency = this.appData.sendSettings?.autoSendFrequency || 600000;
        if (frequency > 0) {
            this.appData.autoSendTimer = setInterval(() => {
                if (Math.random() > 0.5) {
                    this.autoSendMessage();
                }
            }, frequency);
        }
    }
    
    startActiveCallScheduler() {
        if (this.appData.activeCallTimer) clearInterval(this.appData.activeCallTimer);
        
        const settings = this.appData.communicationSettings?.activeCallSettings;
        if (!settings || !settings.enabled || settings.overallFrequency <= 0) return;
        
        const baseInterval = 60000;
        const checkInterval = baseInterval * (100 / Math.max(settings.overallFrequency, 10));
        
        this.appData.activeCallTimer = setInterval(() => {
            const adjustedProbability = this.calculateAdjustedCallProbability();
            if (Math.random() * 100 < adjustedProbability) {
                const callType = this.determineCallType();
                this.simulateIncomingCall(callType);
            }
        }, checkInterval);
    }
    
    calculateAdjustedCallProbability() {
        const settings = this.appData.communicationSettings?.activeCallSettings;
        if (!settings) return 0;
        
        let baseProbability = settings.overallFrequency || 30;
        
        if (settings.respectBusyStatus && this.appData.otherInfo?.status === '在忙') {
            baseProbability *= 0.3;
        }
        
        if (settings.timeSensitivity) {
            const hour = new Date().getHours();
            if (hour >= 22 || hour < 9) {
                baseProbability *= 0.4;
                if (settings.callPreference > 50) baseProbability *= 0.5;
            } else if (hour >= 9 && hour < 12) {
                baseProbability *= 1.2;
            } else if (hour >= 18 && hour < 22) {
                baseProbability *= 1.3;
            }
        }
        
        return Math.max(0, Math.min(100, baseProbability));
    }
    
    determineCallType() {
        const callPref = this.appData.communicationSettings?.activeCallSettings?.callPreference || 50;
        return Math.random() * 100 < callPref ? 'call' : 'video';
    }
    
    simulateIncomingCall(type) {
        if (this.appData.activeCall || this.appData.activeVideo) return;
        
        if (this.appData.communicationSettings) {
            this.appData.communicationSettings.todayIncomingCalls = (this.appData.communicationSettings.todayIncomingCalls || 0) + 1;
            this.renderCommunicationStats();
            this.saveAllData();
        }
        
        if (type === 'call') {
            this.createCallWindow('incoming');
            this.showNotification('对方来电');
        } else {
            this.createVideoWindow('incoming');
            this.showNotification('对方发起视频通话');
        }
    }
    
    // ========================
    // 消息操作
    // ========================
    
    sendMessage() {
        const input = document.getElementById('messageInput');
        if (!input) return;
        
        const text = input.value.trim();
        if (!text && !this.appData.quotedMessage) return;
        
        const userMessage = {
            id: this.dataManager.generateMessageId(),
            text: text,
            sender: 'self',
            time: this.getCurrentTime(),
            read: false,
            quotedMessage: this.appData.quotedMessage ? {...this.appData.quotedMessage} : null
        };
        
        this.appData.messages.push(userMessage);
        this.renderMessages();
        
        input.value = '';
        this.appData.quotedMessage = null;
        input.placeholder = '输入消息...';
        
        this.saveAllData();
        
        const willReply = Math.random() > 0.2;
        if (willReply) {
            this.appData.waitingForReply = true;
            this.startTypingIndicator();
            
            setTimeout(() => {
                if (this.appData.tarotSettings?.enabled && this.appData.tarotSettings.customPhrases?.length > 0) {
                    this.generateTarotReply('reply');
                } else {
                    this.generateReply(userMessage.id);
                }
            }, 1500 + Math.random() * 2000);
        } else {
            this.appData.waitingForReply = false;
            
            setTimeout(() => {
                this.markSelfMessagesAsRead();
                
                if (userMessage.id) {
                    if (!this.appData.readNoReplyMessageIds) this.appData.readNoReplyMessageIds = [];
                    this.appData.readNoReplyMessageIds.push(userMessage.id);
                }
                
                this.renderMessages();
                this.showNotification('对方已读不回');
                this.saveAllData();
            }, 1000 + Math.random() * 3000);
        }
    }
    
    getCurrentTime() {
        const now = new Date();
        return `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;
    }
    
    startTypingIndicator() {
        this.appData.isTyping = true;
        this.renderMessages();
    }
    
    stopTypingIndicator() {
        this.appData.isTyping = false;
        this.renderMessages();
    }
    
    markSelfMessagesAsRead() {
        if (this.appData.messages) {
            this.appData.messages.forEach(msg => {
                if (msg.sender === 'self') {
                    msg.read = true;
                }
            });
        }
    }
    
    generateReply(messageId) {
        this.stopTypingIndicator();
        this.markSelfMessagesAsRead();
        
        if (messageId && this.appData.readNoReplyMessageIds) {
            const index = this.appData.readNoReplyMessageIds.indexOf(messageId);
            if (index > -1) this.appData.readNoReplyMessageIds.splice(index, 1);
        }
        
        const messageCount = Math.floor(Math.random() * (this.appData.sendSettings?.maxMessageCount || 3)) + 1;
        const totalRatio = (this.appData.sendSettings?.stickerRatio || 50) + (this.appData.sendSettings?.phraseRatio || 50);
        const stickerProbability = (this.appData.sendSettings?.stickerRatio || 50) / totalRatio;
        
        const messagesToSend = [];
        
        for (let i = 0; i < messageCount; i++) {
            const isSticker = Math.random() < stickerProbability && this.appData.stickers?.length > 0;
            
            if (isSticker) {
                const randomSticker = this.appData.stickers[Math.floor(Math.random() * this.appData.stickers.length)];
                messagesToSend.push({ type: 'sticker', data: randomSticker.data });
            } else {
                const randomPhrase = this.appData.responsePhrases[Math.floor(Math.random() * this.appData.responsePhrases.length)];
                messagesToSend.push({ type: 'text', data: randomPhrase });
            }
        }
        
        const firstMsg = messagesToSend[0];
        const firstMessage = {
            id: this.dataManager.generateMessageId(),
            isSticker: firstMsg.type === 'sticker',
            [firstMsg.type === 'sticker' ? 'stickerData' : 'text']: firstMsg.data,
            sender: 'other',
            time: this.getCurrentTime(),
            read: true
        };
        
        if (Math.random() < 0.4) {
            const recentUserMessages = this.appData.messages
                .filter(msg => msg.sender === 'self')
                .slice(-3);
            
            if (recentUserMessages.length > 0) {
                const randomUserMessage = recentUserMessages[Math.floor(Math.random() * recentUserMessages.length)];
                firstMessage.quotedMessage = {
                    id: randomUserMessage.id,
                    text: randomUserMessage.text || '',
                    isSticker: randomUserMessage.isSticker || false,
                    stickerData: randomUserMessage.stickerData || null,
                    sender: randomUserMessage.sender,
                    time: randomUserMessage.time
                };
            }
        }
        
        this.appData.messages.push(firstMessage);
        this.renderMessages();
        
        if (messagesToSend.length > 1) {
            for (let i = 1; i < messagesToSend.length; i++) {
                setTimeout(() => {
                    const msg = messagesToSend[i];
                    const additionalMessage = {
                        id: this.dataManager.generateMessageId(),
                        isSticker: msg.type === 'sticker',
                        [msg.type === 'sticker' ? 'stickerData' : 'text']: msg.data,
                        sender: 'other',
                        time: this.getCurrentTime(),
                        read: true
                    };
                    
                    this.appData.messages.push(additionalMessage);
                    this.renderMessages();
                    
                    if (i === messagesToSend.length - 1) {
                        const stickerCount = messagesToSend.filter(m => m.type === 'sticker').length;
                        const textCount = messagesToSend.filter(m => m.type === 'text').length;
                        let notificationText = `对方回复了${messagesToSend.length}条消息`;
                        if (stickerCount > 0 && textCount > 0) {
                            notificationText += `（${textCount}条文字，${stickerCount}个表情包）`;
                        } else if (stickerCount > 0) {
                            notificationText += `（${stickerCount}个表情包）`;
                        }
                        this.showNotification(notificationText);
                    }
                }, (i * 800) + Math.random() * 500);
            }
        } else {
            const msgType = messagesToSend[0].type === 'sticker' ? '一个表情包' : '1条消息';
            this.showNotification(`对方回复了${msgType}`);
        }
        
        this.appData.waitingForReply = false;
        this.saveAllData();
    }
    
    generateTarotReply(source) {
        if (!this.appData.tarotSettings?.enabled || !this.appData.tarotSettings.customPhrases?.length) {
            if (source === 'reply') {
                this.generateReply();
            } else {
                this.autoSendMessage();
            }
            return;
        }
        
        const drawCount = Math.min(this.appData.tarotSettings.drawCount || 1, this.appData.tarotSettings.customPhrases.length);
        let availablePhrases = [...this.appData.tarotSettings.customPhrases];
        
        // 应用同牌正逆位不重复规则
        availablePhrases = availablePhrases.filter(phrase => {
            const parsed = this.parseTarotCard(phrase);
            return this.canDrawCard(parsed);
        });
        
        if (availablePhrases.length === 0) {
            // 重置已抽取记录
            this.appData.drawnCards = new Set();
            availablePhrases = [...this.appData.tarotSettings.customPhrases];
        }
        
        const finalDrawCount = Math.min(drawCount, availablePhrases.length);
        const selectedPhrases = [];
        
        for (let i = 0; i < finalDrawCount && availablePhrases.length > 0; i++) {
            const randomIndex = Math.floor(Math.random() * availablePhrases.length);
            selectedPhrases.push(availablePhrases[randomIndex]);
            
            const parsed = this.parseTarotCard(availablePhrases[randomIndex]);
            if (parsed.cardName) {
                this.appData.drawnCards.add(parsed.cardName);
            }
            
            availablePhrases.splice(randomIndex, 1);
        }
        
        this.sendTarotMessages(selectedPhrases, source);
    }
    
    parseTarotCard(phrase) {
        const trimmed = phrase.trim();
        
        const patterns = [
            /^([^正逆位]+)(正位|逆位)$/,
            /^(正位|逆位)[·\-](.+)$/,
            /^(正位|逆位)[\-](.+)$/,
            /^(.+)[\-]\s*(正位|逆位)$/,
            /^(.+)\s*[\(（](正位|逆位)[\)）]$/
        ];
        
        for (const pattern of patterns) {
            const match = trimmed.match(pattern);
            if (match) {
                let cardName = '', position = '';
                
                if (pattern.toString().includes('[^正逆位]+')) {
                    cardName = match[1].trim();
                    position = match[2].trim();
                } else if (pattern.toString().includes('^(正位|逆位)')) {
                    position = match[1].trim();
                    cardName = match[2].trim();
                } else {
                    cardName = match[1].trim();
                    position = match[2].trim();
                }
                
                cardName = cardName.replace(/^[·\-]\s*|\s*[·\-]$/g, '').trim();
                
                return { original: trimmed, cardName, position, isValid: true };
            }
        }
        
        return { original: trimmed, cardName: trimmed, position: '', isValid: false };
    }
    
    canDrawCard(parsedCard) {
        if (!parsedCard.isValid || !parsedCard.cardName) return true;
        return !this.appData.drawnCards?.has(parsedCard.cardName);
    }
    
    sendTarotMessages(selectedPhrases, source) {
        const firstMessage = {
            id: this.dataManager.generateMessageId(),
            text: selectedPhrases[0],
            sender: 'other',
            time: this.getCurrentTime(),
            read: true,
            isTarot: true
        };
        
        if (Math.random() < 0.25) {
            const recentUserMessages = this.appData.messages
                .filter(msg => msg.sender === 'self')
                .slice(-3);
            
            if (recentUserMessages.length > 0) {
                const randomUserMessage = recentUserMessages[Math.floor(Math.random() * recentUserMessages.length)];
                firstMessage.quotedMessage = {
                    id: randomUserMessage.id,
                    text: randomUserMessage.text || '',
                    isSticker: randomUserMessage.isSticker || false,
                    stickerData: randomUserMessage.stickerData || null,
                    sender: randomUserMessage.sender,
                    time: randomUserMessage.time
                };
            }
        }
        
        this.appData.messages.push(firstMessage);
        this.renderMessages();
        
        if (selectedPhrases.length > 1) {
            for (let i = 1; i < selectedPhrases.length; i++) {
                setTimeout(() => {
                    const additionalMessage = {
                        id: this.dataManager.generateMessageId(),
                        text: selectedPhrases[i],
                        sender: 'other',
                        time: this.getCurrentTime(),
                        read: true,
                        isTarot: true
                    };
                    
                    this.appData.messages.push(additionalMessage);
                    this.renderMessages();
                }, (i * 1000) + Math.random() * 500);
            }
        }
        
        const notificationText = source === 'auto' ? 
            `对方主动抽取了${selectedPhrases.length}张塔罗牌 🔮` : 
            `对方回复了${selectedPhrases.length}张塔罗牌 🔮`;
        
        this.showNotification(notificationText);
        this.saveAllData();
    }
    
    autoSendMessage() {
        this.appData.isTyping = true;
        this.renderMessages();
        
        setTimeout(() => {
            this.appData.isTyping = false;
            
            if (this.appData.tarotSettings?.enabled && this.appData.tarotSettings.customPhrases?.length > 0) {
                this.generateTarotReply('auto');
            } else {
                const messageCount = Math.floor(Math.random() * 3) + 1;
                const totalRatio = (this.appData.sendSettings?.stickerRatio || 50) + (this.appData.sendSettings?.phraseRatio || 50);
                const stickerProbability = (this.appData.sendSettings?.stickerRatio || 50) / totalRatio;
                
                const messagesToSend = [];
                
                for (let i = 0; i < messageCount; i++) {
                    const isSticker = Math.random() < stickerProbability && this.appData.stickers?.length > 0;
                    
                    if (isSticker) {
                        const randomSticker = this.appData.stickers[Math.floor(Math.random() * this.appData.stickers.length)];
                        messagesToSend.push({ type: 'sticker', data: randomSticker.data });
                    } else {
                        const randomPhrase = this.appData.responsePhrases[Math.floor(Math.random() * this.appData.responsePhrases.length)];
                        messagesToSend.push({ type: 'text', data: randomPhrase });
                    }
                }
                
                const firstMsg = messagesToSend[0];
                const firstMessage = {
                    id: this.dataManager.generateMessageId(),
                    isSticker: firstMsg.type === 'sticker',
                    [firstMsg.type === 'sticker' ? 'stickerData' : 'text']: firstMsg.data,
                    sender: 'other',
                    time: this.getCurrentTime(),
                    read: true
                };
                
                if (Math.random() < 0.2) {
                    const recentUserMessages = this.appData.messages
                        .filter(msg => msg.sender === 'self')
                        .slice(-3);
                    
                    if (recentUserMessages.length > 0) {
                        const randomUserMessage = recentUserMessages[Math.floor(Math.random() * recentUserMessages.length)];
                        firstMessage.quotedMessage = {
                            id: randomUserMessage.id,
                            text: randomUserMessage.text || '',
                            isSticker: randomUserMessage.isSticker || false,
                            stickerData: randomUserMessage.stickerData || null,
                            sender: randomUserMessage.sender,
                            time: randomUserMessage.time
                        };
                    }
                }
                
                this.appData.messages.push(firstMessage);
                this.renderMessages();
                
                if (messagesToSend.length > 1) {
                    for (let i = 1; i < messagesToSend.length; i++) {
                        setTimeout(() => {
                            const msg = messagesToSend[i];
                            const additionalMessage = {
                                id: this.dataManager.generateMessageId(),
                                isSticker: msg.type === 'sticker',
                                [msg.type === 'sticker' ? 'stickerData' : 'text']: msg.data,
                                sender: 'other',
                                time: this.getCurrentTime(),
                                read: true
                            };
                            
                            this.appData.messages.push(additionalMessage);
                            this.renderMessages();
                        }, (i * 800) + Math.random() * 500);
                    }
                }
                
                this.showNotification('对方主动发送了消息');
                this.saveAllData();
            }
        }, 1000 + Math.random() * 2000);
    }
    
    quoteMessage(message) {
        if (!message) return;
        
        this.appData.quotedMessage = {
            id: message.id,
            text: message.text || '',
            isSticker: message.isSticker || false,
            stickerData: message.stickerData || null,
            sender: message.sender,
            time: message.time
        };
        
        let quoteText = '';
        if (message.isSticker) {
            quoteText = '[表情包]';
        } else if (message.text) {
            quoteText = message.text.length > 30 ? message.text.substring(0, 30) + '...' : message.text;
        }
        
        const input = document.getElementById('messageInput');
        if (input) {
            input.placeholder = `回复 "${quoteText}"...`;
            input.focus();
        }
        
        this.showNotification('已引用消息，输入回复内容后发送');
    }
    
    deleteMessage(messageId) {
        if (!messageId) return;
        
        const initialLength = this.appData.messages.length;
        this.appData.messages = this.appData.messages.filter(msg => msg.id !== messageId);
        
        if (this.appData.readNoReplyMessageIds) {
            const index = this.appData.readNoReplyMessageIds.indexOf(messageId);
            if (index > -1) this.appData.readNoReplyMessageIds.splice(index, 1);
        }
        
        if (this.appData.messages.length < initialLength) {
            this.renderMessages();
            this.saveAllData();
            this.showNotification('消息已删除');
        }
    }
    
    recallMessage(messageId) {
        if (!messageId) return;
        
        const messageIndex = this.appData.messages.findIndex(msg => msg.id === messageId);
        if (messageIndex === -1) return;
        
        const message = this.appData.messages[messageIndex];
        
        if (message.sender !== 'self') {
            this.showNotification('只能撤回自己发送的消息');
            return;
        }
        
        this.appData.messages[messageIndex].recalled = true;
        this.appData.messages[messageIndex].text = '[已撤回]';
        this.appData.messages[messageIndex].isSticker = false;
        this.appData.messages[messageIndex].stickerData = null;
        
        this.renderMessages();
        this.saveAllData();
        this.showNotification('消息已撤回');
    }
    
    // ========================
    // 设置操作
    // ========================
    
    selectTarotNumber(number) {
        if (!this.appData.tarotSettings) this.appData.tarotSettings = { enabled: false, drawCount: 1, customPhrases: [] };
        this.appData.tarotSettings.drawCount = number;
        
        const tarotCountValue = document.getElementById('tarotCountValue');
        if (tarotCountValue) tarotCountValue.textContent = number;
        
        document.querySelectorAll('.tarot-number').forEach(el => {
            el.classList.remove('active');
            if (parseInt(el.dataset.number) === number) {
                el.classList.add('active');
            }
        });
        
        this.saveAllData();
        this.showNotification(`塔罗牌抽取数量设置为: ${number}`);
    }
    
    saveTarotSettings() {
        const textarea = document.getElementById('tarotTextarea');
        if (!textarea) return;
        
        const text = textarea.value.trim();
        const phrases = text.split('\n')
            .map(p => p.trim())
            .filter(p => p.length > 0);
        
        if (!this.appData.tarotSettings) {
            this.appData.tarotSettings = { enabled: false, drawCount: 1, customPhrases: [] };
        }
        
        this.appData.tarotSettings.customPhrases = phrases;
        
        // 重置已抽取记录
        this.appData.drawnCards = new Set();
        
        this.updateTarotPhraseCount();
        this.updateTarotStatus();
        
        if (phrases.length === 0) {
            this.showNotification('已清空自定义塔罗牌字卡');
        } else {
            this.showNotification(`已保存 ${phrases.length} 张自定义塔罗牌字卡`);
        }
        
        this.saveAllData();
        this.closeSettingsPanel();
    }
    
    loadDefaultTarotCards() {
        if (!this.appData.tarotSettings) {
            this.appData.tarotSettings = { enabled: false, drawCount: 1, customPhrases: [] };
        }
        
        this.appData.tarotSettings.customPhrases = [...this.DEFAULT_TAROT_CARDS];
        
        const textarea = document.getElementById('tarotTextarea');
        if (textarea) textarea.value = this.DEFAULT_TAROT_CARDS.join('\n');
        
        this.updateTarotPhraseCount();
        this.updateTarotStatus();
        this.showNotification('已加载78张默认塔罗牌');
        
        this.appData.drawnCards = new Set();
        this.saveAllData();
    }
    
    clearTarotCards() {
        if (confirm('确定要清空所有塔罗牌字卡吗？')) {
            if (!this.appData.tarotSettings) {
                this.appData.tarotSettings = { enabled: false, drawCount: 1, customPhrases: [] };
            }
            
            this.appData.tarotSettings.customPhrases = [];
            
            const textarea = document.getElementById('tarotTextarea');
            if (textarea) textarea.value = '';
            
            this.updateTarotPhraseCount();
            this.updateTarotStatus();
            this.showNotification('已清空塔罗牌字卡');
            
            this.appData.drawnCards = new Set();
            this.saveAllData();
        }
    }
    
    savePhrases() {
        const textarea = document.getElementById('phrasesTextarea');
        if (!textarea) return;
        
        const text = textarea.value.trim();
        if (!text) {
            this.showNotification('请输入至少一个词条');
            return;
        }
        
        const phrases = text.split('\n')
            .map(p => p.trim())
            .filter(p => p.length > 0);
        
        if (phrases.length === 0) {
            this.showNotification('请输入有效的词条');
            return;
        }
        
        this.appData.responsePhrases = phrases;
        this.updatePhraseCount();
        this.saveAllData();
        this.showNotification(`已保存 ${phrases.length} 个词条`);
        this.closeSettingsPanel();
    }
    
    saveAppearanceSettings() {
        const appTitleInput = document.getElementById('appTitleInput');
        const appSubtitleInput = document.getElementById('appSubtitleInput');
        const loveYear = document.getElementById('loveYear');
        const loveMonth = document.getElementById('loveMonth');
        const loveDay = document.getElementById('loveDay');
        const moodChangeFrequency = document.getElementById('moodChangeFrequency');
        
        if (!this.appData.appearanceSettings) {
            this.appData.appearanceSettings = {
                appTitle: '梦角爱人',
                appSubtitle: '绝对私密的一对一聊天空间',
                loveStartDate: new Date(2024, 0, 1),
                moodChangeFrequency: 600000
            };
        }
        
        if (appTitleInput) this.appData.appearanceSettings.appTitle = appTitleInput.value || '梦角爱人';
        if (appSubtitleInput) this.appData.appearanceSettings.appSubtitle = appSubtitleInput.value || '绝对私密的一对一聊天空间';
        
        if (loveYear && loveMonth && loveDay) {
            const year = parseInt(loveYear.value) || 2024;
            const month = parseInt(loveMonth.value) - 1 || 0;
            const day = parseInt(loveDay.value) || 1;
            this.appData.appearanceSettings.loveStartDate = new Date(year, month, day);
        }
        
        if (moodChangeFrequency) {
            this.appData.appearanceSettings.moodChangeFrequency = parseInt(moodChangeFrequency.value) || 600000;
        }
        
        clearInterval(this.appData.moodTimer);
        this.startMoodChanging();
        
        this.calculateLoveDays();
        this.renderAppearance();
        this.saveAllData();
        this.showNotification('外观设置已保存');
        this.closeSettingsPanel();
    }
    
    saveBackgroundSettings() {
        const slider = document.getElementById('backgroundOpacitySlider');
        if (slider && this.appData.backgroundSettings) {
            this.appData.backgroundSettings.opacity = parseInt(slider.value);
        }
        
        this.saveAllData();
        this.showNotification('背景设置已保存');
        this.closeSettingsPanel();
    }
    
    saveCommunicationSettings() {
        const autoAcceptCalls = document.getElementById('autoAcceptCalls');
        const autoAcceptVideos = document.getElementById('autoAcceptVideos');
        
        if (!this.appData.communicationSettings) {
            this.appData.communicationSettings = {
                autoAcceptCalls: true,
                autoAcceptVideos: true,
                todayCalls: 0,
                todayVideos: 0,
                totalCallTime: 0,
                totalVideoTime: 0,
                todayIncomingCalls: 0,
                activeCallSettings: {
                    enabled: true,
                    overallFrequency: 30,
                    callPreference: 50,
                    presetMode: 'custom',
                    minInterval: 15,
                    maxInterval: 45,
                    respectBusyStatus: true,
                    timeSensitivity: true,
                    adaptToActivity: true
                }
            };
        }
        
        if (autoAcceptCalls) this.appData.communicationSettings.autoAcceptCalls = autoAcceptCalls.checked;
        if (autoAcceptVideos) this.appData.communicationSettings.autoAcceptVideos = autoAcceptVideos.checked;
        
        this.saveAllData();
        this.showNotification('通话设置已保存');
        this.closeSettingsPanel();
    }
    
    // ========================
    // UI操作
    // ========================
    
    openSettings() {
        const panel = document.getElementById('settingsPanel');
        const overlay = document.getElementById('settingsOverlay');
        
        if (panel) panel.classList.add('active');
        if (overlay) overlay.classList.add('active');
        document.body.style.overflow = 'hidden';
    }
    
    closeSettingsPanel() {
        const panel = document.getElementById('settingsPanel');
        const overlay = document.getElementById('settingsOverlay');
        
        if (panel) panel.classList.remove('active');
        if (overlay) overlay.classList.remove('active');
        document.body.style.overflow = '';
    }
    
    switchTab(tabId) {
        if (!document.getElementById('settingsPanel')?.classList.contains('active')) {
            this.openSettings();
        }
        
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');
        
        tabButtons.forEach(btn => {
            btn.classList.toggle('active', btn.getAttribute('data-tab') === tabId);
        });
        
        tabContents.forEach(content => {
            content.classList.toggle('active', content.id === `${tabId}Tab`);
        });
    }
    
    // ========================
    // 通话功能
    // ========================
    
    createCallWindow(type) {
        const existing = document.querySelector('.call-window');
        if (existing) existing.remove();
        
        const callWindow = document.createElement('div');
        callWindow.className = 'call-window';
        callWindow.style.left = '50px';
        callWindow.style.top = '50px';
        
        const avatarContent = this.appData.otherInfo?.avatar ? 
            `<img src="${this.appData.otherInfo.avatar}" alt="${this.appData.otherInfo.nickname}">` : 
            `<span></span>`;
        
        callWindow.innerHTML = `
            <div class="window-header">
                <div class="window-title">
                    <i class="material-icons">call</i>
                    <span>语音通话</span>
                </div>
                <div class="window-controls">
                    <button class="window-btn" id="minimizeCall">−</button>
                    <button class="window-btn" id="closeCall">×</button>
                </div>
            </div>
            <div class="window-content">
                <div class="call-avatar">
                    ${avatarContent}
                </div>
                <div class="calling-text">${type === 'outgoing' ? '等待对方接听...' : '对方来电...'}</div>
                ${type === 'incoming' ? `
                    <div class="call-buttons">
                        <button class="accept-btn" id="acceptCall">
                            <i class="material-icons">call</i>
                            接听
                        </button>
                        <button class="reject-btn" id="rejectCall">
                            <i class="material-icons">call_end</i>
                            拒绝
                        </button>
                    </div>
                ` : ''}
            </div>
        `;
        
        document.body.appendChild(callWindow);
        this.appData.activeCall = callWindow;
        
        this.makeWindowDraggable(callWindow);
        
        if (type === 'incoming') {
            callWindow.querySelector('#acceptCall')?.addEventListener('click', () => this.answerCall());
            callWindow.querySelector('#rejectCall')?.addEventListener('click', () => this.rejectCall());
        }
        
        callWindow.querySelector('#closeCall')?.addEventListener('click', () => this.endCall());
        callWindow.querySelector('#minimizeCall')?.addEventListener('click', () => {
            callWindow.style.display = callWindow.style.display === 'none' ? 'flex' : 'none';
        });
        
        if (type === 'incoming' && this.appData.communicationSettings?.autoAcceptCalls) {
            setTimeout(() => {
                if (this.appData.activeCall === callWindow) this.answerCall();
            }, 2000);
        }
    }
    
    createVideoWindow(type) {
        const existing = document.querySelector('.video-window');
        if (existing) existing.remove();
        
        const videoWindow = document.createElement('div');
        videoWindow.className = 'video-window';
        videoWindow.style.left = '100px';
        videoWindow.style.top = '100px';
        
        const avatarContent = this.appData.otherInfo?.avatar ? 
            `<img src="${this.appData.otherInfo.avatar}" alt="${this.appData.otherInfo.nickname}">` : 
            `<span></span>`;
        
        videoWindow.innerHTML = `
            <div class="window-header">
                <div class="window-title">
                    <i class="material-icons">videocam</i>
                    <span>视频通话</span>
                </div>
                <div class="window-controls">
                    <button class="window-btn" id="minimizeVideo">−</button>
                    <button class="window-btn" id="closeVideo">×</button>
                </div>
            </div>
            <div class="window-content">
                <div class="video-avatar">
                    ${avatarContent}
                </div>
                <div class="calling-text">${type === 'outgoing' ? '等待对方接听...' : '对方视频邀请...'}</div>
                ${type === 'incoming' ? `
                    <div class="call-buttons">
                        <button class="accept-btn" id="acceptVideo">
                            <i class="material-icons">videocam</i>
                            接听
                        </button>
                        <button class="reject-btn" id="rejectVideo">
                            <i class="material-icons">call_end</i>
                            拒绝
                        </button>
                    </div>
                ` : ''}
            </div>
        `;
        
        document.body.appendChild(videoWindow);
        this.appData.activeVideo = videoWindow;
        
        this.makeWindowDraggable(videoWindow);
        
        if (type === 'incoming') {
            videoWindow.querySelector('#acceptVideo')?.addEventListener('click', () => this.answerVideo());
            videoWindow.querySelector('#rejectVideo')?.addEventListener('click', () => this.rejectVideo());
        }
        
        videoWindow.querySelector('#closeVideo')?.addEventListener('click', () => this.endVideo());
        videoWindow.querySelector('#minimizeVideo')?.addEventListener('click', () => {
            videoWindow.style.display = videoWindow.style.display === 'none' ? 'flex' : 'none';
        });
        
        if (type === 'incoming' && this.appData.communicationSettings?.autoAcceptVideos) {
            setTimeout(() => {
                if (this.appData.activeVideo === videoWindow) this.answerVideo();
            }, 2000);
        }
    }
    
    makeWindowDraggable(windowElement) {
    let isDragging = false;
    let offsetX, offsetY;
    
    const header = windowElement.querySelector('.window-header');
    
    header.addEventListener('mousedown', (e) => {
        if (e.target.closest('.window-btn')) return;
        
        isDragging = true;
        const rect = windowElement.getBoundingClientRect();
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;
        windowElement.classList.add('active');
        windowElement.style.transition = 'none';
        e.preventDefault();
    });
    
    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        
        const maxX = window.innerWidth - windowElement.offsetWidth;
        const maxY = window.innerHeight - windowElement.offsetHeight;
        
        let x = e.clientX - offsetX;
        let y = e.clientY - offsetY;
        
        x = Math.max(0, Math.min(x, maxX));
        y = Math.max(0, Math.min(y, maxY));
        
        windowElement.style.left = `${x}px`;
        windowElement.style.top = `${y}px`;
    });
    
    document.addEventListener('mouseup', () => {
        isDragging = false;
        windowElement.classList.remove('active');
        windowElement.style.transition = '';
    });
    
    header.addEventListener('touchstart', (e) => {
        if (e.target.closest('.window-btn')) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        isDragging = true;
        const rect = windowElement.getBoundingClientRect();
        offsetX = touch.clientX - rect.left;
        offsetY = touch.clientY - rect.top;
        windowElement.classList.add('active');
        windowElement.style.transition = 'none';
    }, { passive: false });
    
    document.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
        const touch = e.touches[0];
        
        const maxX = window.innerWidth - windowElement.offsetWidth;
        const maxY = window.innerHeight - windowElement.offsetHeight;
        
        let x = touch.clientX - offsetX;
        let y = touch.clientY - offsetY;
        
        x = Math.max(0, Math.min(x, maxX));
        y = Math.max(0, Math.min(y, maxY));
        
        windowElement.style.left = `${x}px`;
        windowElement.style.top = `${y}px`;
    }, { passive: false });
    
    document.addEventListener('touchend', () => {
        isDragging = false;
        windowElement.classList.remove('active');
        windowElement.style.transition = '';
    });
    
    document.addEventListener('touchcancel', () => {
        isDragging = false;
        windowElement.classList.remove('active');
        windowElement.style.transition = '';
    });
}
    
    answerCall() {
        if (!this.appData.activeCall) return;
        
        const content = this.appData.activeCall.querySelector('.window-content');
        if (!content) return;
        
        content.innerHTML = `
            <div class="call-avatar">
                ${this.appData.otherInfo?.avatar ? 
                  `<img src="${this.appData.otherInfo.avatar}" alt="${this.appData.otherInfo.nickname}">` : 
                  `<span></span>`}
            </div>
            <div class="in-call-text">正在通话中...</div>
            <div class="call-timer" id="callTimer">00:00</div>
            <div class="call-buttons">
                <button class="end-btn" id="endCall">
                    <i class="material-icons">call_end</i>
                    挂断
                </button>
            </div>
        `;
        
        content.querySelector('#endCall')?.addEventListener('click', () => this.endCall());
        
        this.appData.callStartTime = new Date();
        this.startCallTimer();
    }
    
    answerVideo() {
        if (!this.appData.activeVideo) return;
        
        const content = this.appData.activeVideo.querySelector('.window-content');
        if (!content) return;
        
        content.innerHTML = `
            <div class="video-avatar">
                ${this.appData.otherInfo?.avatar ? 
                  `<img src="${this.appData.otherInfo.avatar}" alt="${this.appData.otherInfo.nickname}">` : 
                  `<span></span>`}
            </div>
            <div class="in-call-text">正在视频通话中...</div>
            <div class="call-timer" id="videoTimer">00:00</div>
            <div class="call-buttons">
                <button class="end-btn" id="endVideo">
                    <i class="material-icons">call_end</i>
                    挂断
                </button>
            </div>
        `;
        
        content.querySelector('#endVideo')?.addEventListener('click', () => this.endVideo());
        
        this.appData.callStartTime = new Date();
        this.startCallTimer();
    }
    
    rejectCall() {
        if (!this.appData.activeCall) return;
        
        const callMessage = {
            id: this.dataManager.generateMessageId(),
            type: 'call',
            title: '已拒绝语音通话',
            sender: 'other',
            time: this.getCurrentTime(),
            read: true
        };
        
        this.appData.messages.push(callMessage);
        this.renderMessages();
        
        this.appData.activeCall.remove();
        this.appData.activeCall = null;
        this.showNotification('已拒绝通话');
        this.saveAllData();
    }
    
    rejectVideo() {
        if (!this.appData.activeVideo) return;
        
        const videoMessage = {
            id: this.dataManager.generateMessageId(),
            type: 'video',
            title: '已拒绝视频通话',
            sender: 'other',
            time: this.getCurrentTime(),
            read: true
        };
        
        this.appData.messages.push(videoMessage);
        this.renderMessages();
        
        this.appData.activeVideo.remove();
        this.appData.activeVideo = null;
        this.showNotification('已拒绝视频通话');
        this.saveAllData();
    }
    
    endCall() {
        if (!this.appData.activeCall) return;
        
        const endTime = new Date();
        const durationMs = endTime - this.appData.callStartTime;
        const durationSec = Math.floor(durationMs / 1000);
        const minutes = Math.floor(durationSec / 60);
        const seconds = durationSec % 60;
        const durationText = `${minutes}分${seconds}秒`;
        
        if (this.appData.communicationSettings) {
            this.appData.communicationSettings.totalCallTime = (this.appData.communicationSettings.totalCallTime || 0) + minutes;
        }
        
        const callMessage = {
            id: this.dataManager.generateMessageId(),
            type: 'call',
            title: '语音通话',
            duration: durationText,
            sender: 'self',
            time: this.getCurrentTime(),
            read: true
        };
        
        this.appData.messages.push(callMessage);
        this.renderMessages();
        
        this.appData.activeCall.remove();
        this.appData.activeCall = null;
        
        clearInterval(this.appData.callTimer);
        
        this.showNotification(`通话结束，时长: ${durationText}`);
        this.renderCommunicationStats();
        this.saveAllData();
    }
    
    endVideo() {
        if (!this.appData.activeVideo) return;
        
        const endTime = new Date();
        const durationMs = endTime - this.appData.callStartTime;
        const durationSec = Math.floor(durationMs / 1000);
        const minutes = Math.floor(durationSec / 60);
        const seconds = durationSec % 60;
        const durationText = `${minutes}分${seconds}秒`;
        
        if (this.appData.communicationSettings) {
            this.appData.communicationSettings.totalVideoTime = (this.appData.communicationSettings.totalVideoTime || 0) + minutes;
        }
        
        const videoMessage = {
            id: this.dataManager.generateMessageId(),
            type: 'video',
            title: '视频通话',
            duration: durationText,
            sender: 'self',
            time: this.getCurrentTime(),
            read: true
        };
        
        this.appData.messages.push(videoMessage);
        this.renderMessages();
        
        this.appData.activeVideo.remove();
        this.appData.activeVideo = null;
        
        clearInterval(this.appData.callTimer);
        
        this.showNotification(`视频通话结束，时长: ${durationText}`);
        this.renderCommunicationStats();
        this.saveAllData();
    }
    
    startCall() {
        if (this.appData.activeCall) {
            this.showNotification('当前已有通话进行中');
            return;
        }
        
        this.createCallWindow('outgoing');
        
        if (this.appData.communicationSettings) {
            this.appData.communicationSettings.todayCalls = (this.appData.communicationSettings.todayCalls || 0) + 1;
            this.renderCommunicationStats();
            this.saveAllData();
        }
        
        setTimeout(() => {
            if (this.appData.activeCall) this.answerCall();
        }, 5000 + Math.random() * 5000);
    }
    
    startVideo() {
        if (this.appData.activeVideo) {
            this.showNotification('当前已有视频通话进行中');
            return;
        }
        
        this.createVideoWindow('outgoing');
        
        if (this.appData.communicationSettings) {
            this.appData.communicationSettings.todayVideos = (this.appData.communicationSettings.todayVideos || 0) + 1;
            this.renderCommunicationStats();
            this.saveAllData();
        }
        
        setTimeout(() => {
            if (this.appData.activeVideo) this.answerVideo();
        }, 5000 + Math.random() * 5000);
    }
    
    startCallTimer() {
        clearInterval(this.appData.callTimer);
        
        let seconds = 0;
        this.appData.callTimer = setInterval(() => {
            seconds++;
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            const timerText = `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            
            const callTimer = document.getElementById('callTimer');
            const videoTimer = document.getElementById('videoTimer');
            
            if (callTimer) callTimer.textContent = timerText;
            if (videoTimer) videoTimer.textContent = timerText;
        }, 1000);
    }
    
    // ========================
    // 图片处理
    // ========================
    
    handleImageUpload(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        this.compressImage(file, { maxWidth: 300, maxHeight: 300, quality: 0.7 })
            .then(compressedDataUrl => {
                const imageMessage = {
                    id: this.dataManager.generateMessageId(),
                    isSticker: true,
                    stickerData: compressedDataUrl,
                    sender: 'self',
                    time: this.getCurrentTime(),
                    read: false,
                    quotedMessage: this.appData.quotedMessage ? {...this.appData.quotedMessage} : null
                };
                
                this.appData.messages.push(imageMessage);
                this.renderMessages();
                
                this.appData.quotedMessage = null;
                const input = document.getElementById('messageInput');
                if (input) input.placeholder = '输入消息...';
                
                this.saveAllData();
                
                const willReply = Math.random() > 0.3;
                if (willReply) {
                    this.appData.waitingForReply = true;
                    this.startTypingIndicator();
                    
                    setTimeout(() => {
                        if (this.appData.tarotSettings?.enabled && this.appData.tarotSettings.customPhrases?.length > 0) {
                            this.generateTarotReply('reply');
                        } else {
                            this.generateReply(imageMessage.id);
                        }
                    }, 1500 + Math.random() * 2000);
                } else {
                    this.appData.waitingForReply = false;
                    
                    setTimeout(() => {
                        this.markSelfMessagesAsRead();
                        
                        if (imageMessage.id) {
                            if (!this.appData.readNoReplyMessageIds) this.appData.readNoReplyMessageIds = [];
                            this.appData.readNoReplyMessageIds.push(imageMessage.id);
                        }
                        
                        this.renderMessages();
                        this.showNotification('对方已读不回');
                        this.saveAllData();
                    }, 1000 + Math.random() * 3000);
                }
            });
        
        e.target.value = '';
    }
    
    handleStickerUpload(e) {
        const files = e.target.files;
        
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            
            this.compressImage(file, { maxWidth: 200, maxHeight: 200, quality: 0.6 })
                .then(compressedDataUrl => {
                    const stickerData = {
                        id: Date.now() + i,
                        data: compressedDataUrl,
                        name: file.name
                    };
                    
                    if (!this.appData.stickers) this.appData.stickers = [];
                    this.appData.stickers.push(stickerData);
                    
                    this.renderStickerPreview();
                    this.saveAllData();
                    this.showNotification(`已添加表情包: ${file.name}`);
                });
        }
        
        e.target.value = '';
    }
    
    handleBackgroundUpload(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        // 直接读取原图，不压缩
        const reader = new FileReader();
        reader.onload = (e) => {
            if (!this.appData.backgroundSettings) {
                this.appData.backgroundSettings = { backgroundImage: null, opacity: 100 };
            }
            
            this.appData.backgroundSettings.backgroundImage = e.target.result;
            
            this.updateBackgroundPreview();
            this.applyBackgroundSettings();
            this.saveAllData();
            this.showNotification('背景图片已上传');
        };
        reader.readAsDataURL(file);
        
        e.target.value = '';
    }
    
    compressImage(file, options) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    let width = img.width;
                    let height = img.height;
                    
                    if (width > height) {
                        if (width > options.maxWidth) {
                            height = Math.round(height * options.maxWidth / width);
                            width = options.maxWidth;
                        }
                    } else {
                        if (height > options.maxHeight) {
                            width = Math.round(width * options.maxHeight / height);
                            height = options.maxHeight;
                        }
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    const compressedDataUrl = canvas.toDataURL('image/jpeg', options.quality);
                    resolve(compressedDataUrl);
                };
                img.onerror = reject;
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });
    }
    
    removeBackground() {
        if (this.appData.backgroundSettings) {
            this.appData.backgroundSettings.backgroundImage = null;
            this.appData.backgroundSettings.opacity = 100;
        }
        
        const slider = document.getElementById('backgroundOpacitySlider');
        const value = document.getElementById('backgroundOpacityValue');
        
        if (slider) slider.value = 100;
        if (value) value.textContent = '100%';
        
        this.updateBackgroundPreview();
        this.applyBackgroundSettings();
        this.saveAllData();
        this.showNotification('已恢复默认背景');
    }
    
    // ========================
    // 用户信息编辑
    // ========================
    
    openUserEditModal(userType) {
        this.appData.editingUserType = userType;
        const userInfo = userType === 'self' ? this.appData.selfInfo : this.appData.otherInfo;
        
        const modalTitle = document.getElementById('modalTitle');
        if (modalTitle) {
            modalTitle.textContent = userType === 'self' ? '编辑我的信息' : '编辑对方信息';
        }
        
        const modalNicknameInput = document.getElementById('modalNicknameInput');
        if (modalNicknameInput) {
            modalNicknameInput.value = userInfo?.nickname || '';
        }
        
        const avatarPreview = document.getElementById('avatarPreview');
        if (avatarPreview) {
            avatarPreview.innerHTML = '';
            if (userInfo?.avatar) {
                avatarPreview.innerHTML = `<img src="${userInfo.avatar}" alt="${userInfo.nickname}">`;
            } else {
                avatarPreview.innerHTML = `<span></span>`;
            }
        }
        
        const modal = document.getElementById('userModal');
        if (modal) {
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }
    }
    
    closeUserEditModal() {
        const modal = document.getElementById('userModal');
        if (modal) {
            modal.classList.remove('active');
            document.body.style.overflow = '';
        }
        this.appData.editingUserType = null;
    }
    
    saveUserInfo() {
        const userType = this.appData.editingUserType;
        if (!userType) return;
        
        const userInfo = userType === 'self' ? this.appData.selfInfo : this.appData.otherInfo;
        if (!userInfo) return;
        
        const modalNicknameInput = document.getElementById('modalNicknameInput');
        if (modalNicknameInput && modalNicknameInput.value.trim()) {
            userInfo.nickname = modalNicknameInput.value.trim();
        }
        
        this.renderUserInfo();
        this.renderMessages();
        this.saveAllData();
        
        this.showNotification(`${userType === 'self' ? '我的' : '对方'}信息已更新`);
        this.closeUserEditModal();
    }
    
    handleAvatarUpload(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        const userType = this.appData.editingUserType;
        if (!userType) return;
        
        const userInfo = userType === 'self' ? this.appData.selfInfo : this.appData.otherInfo;
        if (!userInfo) return;
        
        this.compressImage(file, { maxWidth: 200, maxHeight: 200, quality: 0.7 })
            .then(compressedDataUrl => {
                userInfo.avatar = compressedDataUrl;
                
                const avatarPreview = document.getElementById('avatarPreview');
                if (avatarPreview) {
                    avatarPreview.innerHTML = `<img src="${userInfo.avatar}" alt="${userInfo.nickname}">`;
                }
                
                this.showNotification('头像已更新');
                this.saveAllData();
            });
        
        e.target.value = '';
    }
    
    // ========================
    // 主动呼叫设置
    // ========================
    
    updateOverallFrequency() {
        const slider = document.getElementById('overallFrequencySlider');
        if (!slider) return;
        
        const value = parseInt(slider.value);
        
        if (!this.appData.communicationSettings) {
            this.appData.communicationSettings = { activeCallSettings: {} };
        }
        if (!this.appData.communicationSettings.activeCallSettings) {
            this.appData.communicationSettings.activeCallSettings = {};
        }
        
        this.appData.communicationSettings.activeCallSettings.overallFrequency = value;
        this.appData.communicationSettings.activeCallSettings.enabled = value > 0;
        this.appData.communicationSettings.activeCallSettings.presetMode = 'custom';
        
        this.updateOverallFrequencyDisplay();
        this.updatePresetButtons();
        this.updateActiveCallPreview();
        
        this.restartActiveCallScheduler();
        this.saveAllData();
    }
    
    updateCallPreference() {
        const slider = document.getElementById('callPreferenceSlider');
        if (!slider) return;
        
        const value = parseInt(slider.value);
        
        if (!this.appData.communicationSettings) {
            this.appData.communicationSettings = { activeCallSettings: {} };
        }
        if (!this.appData.communicationSettings.activeCallSettings) {
            this.appData.communicationSettings.activeCallSettings = {};
        }
        
        this.appData.communicationSettings.activeCallSettings.callPreference = value;
        this.appData.communicationSettings.activeCallSettings.presetMode = 'custom';
        
        this.updateCallPreferenceDisplay();
        this.updatePresetButtons();
        this.updateActiveCallPreview();
        
        this.saveAllData();
    }
    
    applyPresetMode(preset) {
        if (!this.PRESET_MODES[preset]) return;
        
        const presetConfig = this.PRESET_MODES[preset];
        
        if (!this.appData.communicationSettings) {
            this.appData.communicationSettings = { activeCallSettings: {} };
        }
        if (!this.appData.communicationSettings.activeCallSettings) {
            this.appData.communicationSettings.activeCallSettings = {};
        }
        
        this.appData.communicationSettings.activeCallSettings.overallFrequency = presetConfig.overallFrequency || 30;
        this.appData.communicationSettings.activeCallSettings.callPreference = presetConfig.callPreference || 50;
        this.appData.communicationSettings.activeCallSettings.presetMode = preset;
        
        if (presetConfig.minInterval !== undefined) {
            this.appData.communicationSettings.activeCallSettings.minInterval = presetConfig.minInterval;
        }
        if (presetConfig.maxInterval !== undefined) {
            this.appData.communicationSettings.activeCallSettings.maxInterval = presetConfig.maxInterval;
        }
        
        const freqSlider = document.getElementById('overallFrequencySlider');
        const prefSlider = document.getElementById('callPreferenceSlider');
        
        if (freqSlider) freqSlider.value = this.appData.communicationSettings.activeCallSettings.overallFrequency;
        if (prefSlider) prefSlider.value = this.appData.communicationSettings.activeCallSettings.callPreference;
        
        this.updateOverallFrequencyDisplay();
        this.updateCallPreferenceDisplay();
        this.updatePresetButtons();
        this.updateActiveCallPreview();
        
        this.restartActiveCallScheduler();
        this.showNotification(`已切换到${presetConfig.name}`);
        this.saveAllData();
    }
    
    restartActiveCallScheduler() {
        if (this.appData.activeCallTimer) {
            clearInterval(this.appData.activeCallTimer);
        }
        this.startActiveCallScheduler();
    }
    
    // ========================
    // 云导入导出（已删除）
    // ========================
    
    // 云导入导出功能已全部删除
    
    // ========================
    // 事件监听设置
    // ========================
    
    setupEventListeners() {
        // 发送消息
        const sendBtn = document.getElementById('sendButton');
        if (sendBtn) sendBtn.addEventListener('click', () => this.sendMessage());
        
        const input = document.getElementById('messageInput');
        if (input) {
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') this.sendMessage();
            });
        }
        
        // 继续按钮
        const continueBtn = document.getElementById('continueButton');
        if (continueBtn) {
            continueBtn.addEventListener('click', () => this.requestContinueMessages());
        }
        
        // 图片上传
        const uploadBtn = document.getElementById('uploadImageButton');
        const imageUpload = document.getElementById('imageUpload');
        if (uploadBtn && imageUpload) {
            uploadBtn.addEventListener('click', () => imageUpload.click());
            imageUpload.addEventListener('change', (e) => this.handleImageUpload(e));
        }
        
        // 设置面板
        const settingsToggle = document.getElementById('settingsToggle');
        if (settingsToggle) {
            settingsToggle.addEventListener('click', () => this.openSettings());
        }
        
        // ===== 新增：夜间模式切换按钮事件 =====
        const themeToggle = document.getElementById('themeToggle');
        if (themeToggle) {
            themeToggle.addEventListener('click', () => {
                document.documentElement.classList.toggle('night-mode');
                
                // 更新图标
                const icon = themeToggle.querySelector('i');
                if (icon) {
                    if (document.documentElement.classList.contains('night-mode')) {
                        icon.textContent = 'light_mode'; // 夜间模式显示太阳
                    } else {
                        icon.textContent = 'dark_mode'; // 日间模式显示月亮
                    }
                }
            });
        }
        
        const overlay = document.getElementById('settingsOverlay');
        if (overlay) {
            overlay.addEventListener('click', () => this.closeSettingsPanel());
        }
        
        const closeSettings = document.getElementById('closeSettings');
        if (closeSettings) {
            closeSettings.addEventListener('click', () => this.closeSettingsPanel());
        }
        
        // 表情包
        const addStickerBtn = document.getElementById('addStickerBtn');
        const stickerUpload = document.getElementById('stickerUpload');
        if (addStickerBtn && stickerUpload) {
            addStickerBtn.addEventListener('click', () => stickerUpload.click());
            stickerUpload.addEventListener('change', (e) => this.handleStickerUpload(e));
        }
        
        // 词条保存
        const savePhrasesBtn = document.getElementById('savePhrasesBtn');
        if (savePhrasesBtn) {
            savePhrasesBtn.addEventListener('click', () => this.savePhrases());
        }
        
        // 塔罗牌
        const tarotModeToggle = document.getElementById('tarotModeToggle');
        if (tarotModeToggle) {
            tarotModeToggle.addEventListener('change', () => {
                if (!this.appData.tarotSettings) {
                    this.appData.tarotSettings = { enabled: false, drawCount: 1, customPhrases: [] };
                }
                this.appData.tarotSettings.enabled = tarotModeToggle.checked;
                this.updateTarotStatus();
                this.saveAllData();
                this.showNotification(`塔罗牌梦占模式 ${this.appData.tarotSettings.enabled ? '已开启' : '已关闭'}`);
            });
        }
        
        const saveTarotBtn = document.getElementById('saveTarotBtn');
        if (saveTarotBtn) {
            saveTarotBtn.addEventListener('click', () => this.saveTarotSettings());
        }
        
        const tarotTextarea = document.getElementById('tarotTextarea');
        if (tarotTextarea) {
            tarotTextarea.addEventListener('input', () => this.updateTarotPhraseCount());
        }
        
        const loadDefaultTarotBtn = document.getElementById('loadDefaultTarotBtn');
        if (loadDefaultTarotBtn) {
            loadDefaultTarotBtn.addEventListener('click', () => this.loadDefaultTarotCards());
        }
        
        const clearTarotBtn = document.getElementById('clearTarotBtn');
        if (clearTarotBtn) {
            clearTarotBtn.addEventListener('click', () => this.clearTarotCards());
        }
        
        // 背景
        const uploadBackgroundOption = document.getElementById('uploadBackgroundOption');
        const backgroundUpload = document.getElementById('backgroundUpload');
        if (uploadBackgroundOption && backgroundUpload) {
            uploadBackgroundOption.addEventListener('click', () => backgroundUpload.click());
            backgroundUpload.addEventListener('change', (e) => this.handleBackgroundUpload(e));
        }
        
        const removeBackgroundBtn = document.getElementById('removeBackgroundBtn');
        if (removeBackgroundBtn) {
            removeBackgroundBtn.addEventListener('click', () => this.removeBackground());
        }
        
        const bgOpacitySlider = document.getElementById('backgroundOpacitySlider');
        if (bgOpacitySlider) {
            bgOpacitySlider.addEventListener('input', (e) => {
                const value = e.target.value;
                const display = document.getElementById('backgroundOpacityValue');
                if (display) display.textContent = `${value}%`;
                if (this.appData.backgroundSettings) {
                    this.appData.backgroundSettings.opacity = parseInt(value);
                    this.applyBackgroundSettings();
                }
            });
        }
        
        const saveBackgroundBtn = document.getElementById('saveBackgroundBtn');
        if (saveBackgroundBtn) {
            saveBackgroundBtn.addEventListener('click', () => this.saveBackgroundSettings());
        }
        
        // 标签页
        const tabButtons = document.querySelectorAll('.tab-button');
        tabButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const tabId = btn.getAttribute('data-tab');
                this.switchTab(tabId);
            });
        });
        
        // 发送设置
        const stickerRatioSlider = document.getElementById('stickerRatioSlider');
        if (stickerRatioSlider) {
            stickerRatioSlider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                const display = document.getElementById('stickerRatioValue');
                if (display) display.textContent = `${value}%`;
                
                if (!this.appData.sendSettings) {
                    this.appData.sendSettings = { stickerRatio: 50, phraseRatio: 50, maxMessageCount: 3, autoSendFrequency: 600000 };
                }
                this.appData.sendSettings.stickerRatio = value;
                this.appData.sendSettings.phraseRatio = 100 - value;
                
                const phraseSlider = document.getElementById('phraseRatioSlider');
                const phraseDisplay = document.getElementById('phraseRatioValue');
                if (phraseSlider) phraseSlider.value = 100 - value;
                if (phraseDisplay) phraseDisplay.textContent = `${100 - value}%`;
                
                this.saveAllData();
            });
        }
        
        const phraseRatioSlider = document.getElementById('phraseRatioSlider');
        if (phraseRatioSlider) {
            phraseRatioSlider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                const display = document.getElementById('phraseRatioValue');
                if (display) display.textContent = `${value}%`;
                
                if (!this.appData.sendSettings) {
                    this.appData.sendSettings = { stickerRatio: 50, phraseRatio: 50, maxMessageCount: 3, autoSendFrequency: 600000 };
                }
                this.appData.sendSettings.phraseRatio = value;
                this.appData.sendSettings.stickerRatio = 100 - value;
                
                const stickerSlider = document.getElementById('stickerRatioSlider');
                const stickerDisplay = document.getElementById('stickerRatioValue');
                if (stickerSlider) stickerSlider.value = 100 - value;
                if (stickerDisplay) stickerDisplay.textContent = `${100 - value}%`;
                
                this.saveAllData();
            });
        }
        
        const maxMessageCount = document.getElementById('maxMessageCount');
        if (maxMessageCount) {
            maxMessageCount.addEventListener('change', (e) => {
                if (!this.appData.sendSettings) {
                    this.appData.sendSettings = { stickerRatio: 50, phraseRatio: 50, maxMessageCount: 3, autoSendFrequency: 600000 };
                }
                this.appData.sendSettings.maxMessageCount = parseInt(e.target.value);
                this.saveAllData();
            });
        }
        
        const autoSendFrequency = document.getElementById('autoSendFrequency');
        if (autoSendFrequency) {
            autoSendFrequency.addEventListener('change', (e) => {
                if (!this.appData.sendSettings) {
                    this.appData.sendSettings = { stickerRatio: 50, phraseRatio: 50, maxMessageCount: 3, autoSendFrequency: 600000 };
                }
                this.appData.sendSettings.autoSendFrequency = parseInt(e.target.value);
                this.restartAutoSending();
                this.saveAllData();
            });
        }
        
        // 外观设置
        const saveAppearanceBtn = document.getElementById('saveAppearanceBtn');
        if (saveAppearanceBtn) {
            saveAppearanceBtn.addEventListener('click', () => this.saveAppearanceSettings());
        }
        
        const loveDays = document.getElementById('loveDays');
        if (loveDays) {
            loveDays.addEventListener('click', () => this.switchTab('appearance'));
        }
        
        // 通信设置
        const startCallButton = document.getElementById('startCallButton');
        if (startCallButton) {
            startCallButton.addEventListener('click', () => this.startCall());
        }
        
        const startVideoButton = document.getElementById('startVideoButton');
        if (startVideoButton) {
            startVideoButton.addEventListener('click', () => this.startVideo());
        }
        
        const autoAcceptCalls = document.getElementById('autoAcceptCalls');
        if (autoAcceptCalls) {
            autoAcceptCalls.addEventListener('change', (e) => {
                if (!this.appData.communicationSettings) {
                    this.appData.communicationSettings = { autoAcceptCalls: true };
                }
                this.appData.communicationSettings.autoAcceptCalls = e.target.checked;
                this.saveAllData();
            });
        }
        
        const autoAcceptVideos = document.getElementById('autoAcceptVideos');
        if (autoAcceptVideos) {
            autoAcceptVideos.addEventListener('change', (e) => {
                if (!this.appData.communicationSettings) {
                    this.appData.communicationSettings = { autoAcceptVideos: true };
                }
                this.appData.communicationSettings.autoAcceptVideos = e.target.checked;
                this.saveAllData();
            });
        }
        
        const saveCommunicationBtn = document.getElementById('saveCommunicationBtn');
        if (saveCommunicationBtn) {
            saveCommunicationBtn.addEventListener('click', () => this.saveCommunicationSettings());
        }
        
        // 主动呼叫设置
        const overallFreqSlider = document.getElementById('overallFrequencySlider');
        if (overallFreqSlider) {
            overallFreqSlider.addEventListener('input', () => this.updateOverallFrequency());
        }
        
        const callPrefSlider = document.getElementById('callPreferenceSlider');
        if (callPrefSlider) {
            callPrefSlider.addEventListener('input', () => this.updateCallPreference());
        }
        
        const presetBtns = document.querySelectorAll('.preset-btn');
        presetBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                const preset = e.currentTarget.getAttribute('data-preset');
                this.applyPresetMode(preset);
            });
        });
        
        // ===== 音乐播放器事件监听 =====
        const musicUploadArea = document.getElementById('musicUploadArea');
        const musicUpload = document.getElementById('musicUpload');
        if (musicUploadArea && musicUpload) {
            musicUploadArea.addEventListener('click', () => musicUpload.click());
            musicUpload.addEventListener('change', (e) => this.handleMusicUpload(e));
        }
        
        const musicFrequencySlider = document.getElementById('musicFrequencySlider');
        if (musicFrequencySlider) {
            musicFrequencySlider.addEventListener('input', (e) => {
                const value = document.getElementById('musicFrequencyValue');
                if (value) value.textContent = `${e.target.value}%`;
            });
        }
        
        const saveMusicSettingsBtn = document.getElementById('saveMusicSettingsBtn');
        if (saveMusicSettingsBtn) {
            saveMusicSettingsBtn.addEventListener('click', () => this.saveMusicSettings());
        }
        
        // 云导入相关事件已删除
        
        // 用户信息
        const selfUserInfo = document.getElementById('selfUserInfo');
        if (selfUserInfo) {
            selfUserInfo.addEventListener('click', () => this.openUserEditModal('self'));
        }
        
        const otherUserInfo = document.getElementById('otherUserInfo');
        if (otherUserInfo) {
            otherUserInfo.addEventListener('click', () => this.openUserEditModal('other'));
        }
        
        // 模态框
        const cancelEditBtn = document.getElementById('cancelEditBtn');
        if (cancelEditBtn) {
            cancelEditBtn.addEventListener('click', () => this.closeUserEditModal());
        }
        
        const saveUserInfoBtn = document.getElementById('saveUserInfoBtn');
        if (saveUserInfoBtn) {
            saveUserInfoBtn.addEventListener('click', () => this.saveUserInfo());
        }
        
        const uploadAvatarBtn = document.getElementById('uploadAvatarBtn');
        const modalAvatarUpload = document.getElementById('modalAvatarUpload');
        if (uploadAvatarBtn && modalAvatarUpload) {
            uploadAvatarBtn.addEventListener('click', () => modalAvatarUpload.click());
            modalAvatarUpload.addEventListener('change', (e) => this.handleAvatarUpload(e));
        }
        
        // 点击其他地方关闭消息操作菜单
        document.addEventListener('click', (e) => {
            if (this.appData.activeMessageActions && 
                !this.appData.activeMessageActions.contains(e.target) &&
                !e.target.closest('.message')) {
                this.appData.activeMessageActions.style.display = 'none';
                this.appData.activeMessageActions = null;
            }
        });
    }
    
    restartAutoSending() {
        if (this.appData.autoSendTimer) {
            clearInterval(this.appData.autoSendTimer);
        }
        this.startAutoSending();
    }
    
    requestContinueMessages() {
        this.appData.isTyping = true;
        this.renderMessages();
        
        setTimeout(() => {
            this.appData.isTyping = false;
            
            if (this.appData.tarotSettings?.enabled && this.appData.tarotSettings.customPhrases?.length > 0) {
                this.generateTarotReply('continue');
                this.showNotification(`对方抽取了塔罗牌进行占卜 🔮`);
            } else {
                const messageCount = Math.floor(Math.random() * 3) + 1;
                this.autoSendMessage();
                this.showNotification(`对方继续发送了${messageCount}条消息`);
            }
        }, 1000 + Math.random() * 2000);
    }
    
    // ========================
    // 音乐播放器功能
    // ========================

    /**
     * 初始化音乐设置UI
     */
    initMusicSettingsUI() {
        const musicFrequencySlider = document.getElementById('musicFrequencySlider');
        const musicFrequencyValue = document.getElementById('musicFrequencyValue');
        const autoPlayMusic = document.getElementById('autoPlayMusic');
        const playModeRadios = document.querySelectorAll('input[name="musicPlayMode"]');
        
        if (!this.appData.musicSettings) {
            this.appData.musicSettings = { musicList: [] };
        }
        
        if (musicFrequencySlider && this.appData.musicSettings) {
            musicFrequencySlider.value = this.appData.musicSettings.musicFrequency || 30;
        }
        if (musicFrequencyValue && this.appData.musicSettings) {
            musicFrequencyValue.textContent = `${this.appData.musicSettings.musicFrequency || 30}%`;
        }
        if (autoPlayMusic && this.appData.musicSettings) {
            autoPlayMusic.checked = this.appData.musicSettings.autoPlayMusic !== false;
        }
        
        if (playModeRadios.length && this.appData.musicSettings) {
            playModeRadios.forEach(radio => {
                radio.checked = radio.value === (this.appData.musicSettings.playMode || 'random');
            });
        }
        
        this.renderMusicList();
    }

    /**
     * 渲染音乐列表
     */
    renderMusicList() {
        const musicListEl = document.getElementById('musicList');
        if (!musicListEl) return;
        
        if (!this.appData.musicSettings) {
            this.appData.musicSettings = { musicList: [] };
        }
        
        const musicList = this.appData.musicSettings.musicList || [];
        
        if (musicList.length === 0) {
            musicListEl.innerHTML = `
                <div class="music-empty">
                    <i class="material-icons">library_music</i>
                    <span>暂无音乐，请上传音频文件</span>
                </div>
            `;
            return;
        }
        
        musicListEl.innerHTML = '';
        musicList.forEach((music, index) => {
            const musicCard = document.createElement('div');
            musicCard.className = 'music-item-card';
            
            const size = music.size ? (music.size / 1024 / 1024).toFixed(2) + 'MB' : '未知大小';
            
            musicCard.innerHTML = `
                <div class="music-item-icon">
                    <i class="material-icons">music_note</i>
                </div>
                <div class="music-item-info">
                    <div class="music-item-name">${music.name || '未知歌曲'}</div>
                    <div class="music-item-size">${size}</div>
                </div>
                <div class="music-item-actions">
                    <button class="music-item-play" data-index="${index}">
                        <i class="material-icons" style="font-size: 0.8rem;">play_arrow</i> 播放
                    </button>
                    <button class="music-item-delete" data-index="${index}">
                        <i class="material-icons" style="font-size: 0.8rem;">delete</i>
                    </button>
                </div>
            `;
            
            musicCard.querySelector('.music-item-play').addEventListener('click', (e) => {
                e.stopPropagation();
                this.openMusicPlayer(music);
            });
            
            musicCard.querySelector('.music-item-delete').addEventListener('click', (e) => {
                e.stopPropagation();
                this.deleteMusic(index);
            });
            
            musicListEl.appendChild(musicCard);
        });
    }

    /**
     * 处理音乐文件上传
     */
    handleMusicUpload(e) {
        const files = e.target.files;
        
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            
            if (!file.type.startsWith('audio/')) {
                this.showNotification('请上传音频文件');
                continue;
            }
            
            if (file.size > 10 * 1024 * 1024) {
                this.showNotification(`文件 ${file.name} 超过10MB，请压缩后上传`);
                continue;
            }
            
            const reader = new FileReader();
            reader.onload = (event) => {
                const musicData = {
                    id: Date.now() + i + Math.random(),
                    name: file.name.replace(/\.[^/.]+$/, ''),
                    filename: file.name,
                    data: event.target.result,
                    size: file.size,
                    type: file.type,
                    uploadTime: new Date().toISOString()
                };
                
                if (!this.appData.musicSettings) {
                    this.appData.musicSettings = { musicList: [] };
                }
                if (!this.appData.musicSettings.musicList) {
                    this.appData.musicSettings.musicList = [];
                }
                
                this.appData.musicSettings.musicList.push(musicData);
                this.renderMusicList();
                this.saveAllData();
                this.showNotification(`已添加歌曲: ${musicData.name}`);
            };
            reader.readAsDataURL(file);
        }
        
        e.target.value = '';
    }

    /**
     * 删除音乐
     */
    deleteMusic(index) {
        if (!this.appData.musicSettings?.musicList) return;
        
        const musicName = this.appData.musicSettings.musicList[index]?.name;
        if (confirm(`确定要删除《${musicName}》吗？`)) {
            this.appData.musicSettings.musicList.splice(index, 1);
            this.renderMusicList();
            this.saveAllData();
            this.showNotification(`已删除歌曲: ${musicName}`);
            
            if (this.appData.activeMusicPlayer && 
                this.appData.currentPlayingMusic?.id === this.appData.musicSettings.musicList[index]?.id) {
                this.closeMusicPlayer();
            }
        }
    }

    /**
     * 打开音乐播放器
     */
    openMusicPlayer(music) {
        const existing = document.querySelector('.music-window');
        if (existing) existing.remove();
        
        this.appData.currentPlayingMusic = music;
        
        const musicWindow = document.createElement('div');
        musicWindow.className = 'music-window';
        musicWindow.style.left = '80px';
        musicWindow.style.top = '150px';
        
        const coverImage = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI4MCIgaGVpZ2h0PSI4MCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTIgM2MtNC45NyAwLTkgNC4wMy05IDlzNC4wMyA5IDkgOSA5LTQuMDMgOS05LTQuMDMtOS05LTl6bTAgMTZjLTMuODYgMC03LTMuMTQtNy03czMuMTQtNyA3LTcgNyAzLjE0IDcgNy0zLjE0IDctNyA3eiIgZmlsbD0iIzhhN2Y4ZCIvPjxwYXRoIGQ9Ik0xMCA5djZsNS0zLTUtM3oiIGZpbGw9IiM4YTdmOGQiLz48L3N2Zz4=';
        
        musicWindow.innerHTML = `
            <div class="window-header">
                <div class="window-title">
                    <i class="material-icons">music_note</i>
                    <span>音乐播放器</span>
                </div>
                <div class="window-controls">
                    <button class="window-btn" id="minimizeMusic">−</button>
                    <button class="window-btn" id="closeMusic">×</button>
                </div>
            </div>
            <div class="window-content" style="padding: 0;">
                <div class="music-cd-container">
                    <div class="music-cd" id="musicCd">
                        <img src="${coverImage}" alt="CD">
                    </div>
                    <div class="music-info">
                        <div class="music-title" id="musicTitle">${music.name || '未知歌曲'}</div>
                        <div class="music-artist">
                            <i class="material-icons" style="font-size: 0.7rem;">album</i>
                            梦角爱人音乐库
                        </div>
                        <div class="music-progress-container">
                            <div class="music-progress-bar" id="musicProgressBar">
                                <div class="music-progress-fill" id="musicProgressFill" style="width: 0%;">
                                    <div class="music-progress-handle"></div>
                                </div>
                            </div>
                            <div class="music-time">
                                <span id="currentTime">00:00</span>
                                <span id="duration">00:00</span>
                            </div>
                        </div>
                        <div class="music-controls-bar">
                            <button class="music-control-btn" id="prevMusic">
                                <i class="material-icons">skip_previous</i>
                            </button>
                            <button class="music-control-btn" id="playPauseMusic" style="background: #8a7f8d; color: white;">
                                <i class="material-icons">play_arrow</i>
                            </button>
                            <button class="music-control-btn" id="nextMusic">
                                <i class="material-icons">skip_next</i>
                            </button>
                            <button class="music-control-btn" id="closeMusicPlayer">
                                <i class="material-icons">close</i>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        document.body.appendChild(musicWindow);
        this.appData.activeMusicPlayer = musicWindow;
        this.appData.isMusicPlaying = false;
        this.appData.musicAudio = null;
        
        this.makeWindowDraggable(musicWindow);
        this.initMusicAudio(music);
        
        musicWindow.querySelector('#playPauseMusic').addEventListener('click', () => this.toggleMusicPlay());
        musicWindow.querySelector('#prevMusic').addEventListener('click', () => this.playPrevMusic());
        musicWindow.querySelector('#nextMusic').addEventListener('click', () => this.playNextMusic());
        musicWindow.querySelector('#closeMusic').addEventListener('click', () => this.closeMusicPlayer());
        musicWindow.querySelector('#closeMusicPlayer').addEventListener('click', () => this.closeMusicPlayer());
        musicWindow.querySelector('#minimizeMusic').addEventListener('click', () => {
            musicWindow.style.display = musicWindow.style.display === 'none' ? 'flex' : 'none';
        });
        
        const progressBar = musicWindow.querySelector('#musicProgressBar');
        progressBar.addEventListener('click', (e) => this.seekMusic(e));
        
        const cd = musicWindow.querySelector('#musicCd');
        cd.addEventListener('click', () => this.toggleMusicPlay());
    }

    /**
     * 初始化音频
     */
    initMusicAudio(music) {
        if (!music || !music.data) return;
        
        if (this.appData.musicAudio) {
            this.appData.musicAudio.pause();
            this.appData.musicAudio = null;
        }
        
        const audio = new Audio(music.data);
        audio.volume = 0.8;
        
        audio.addEventListener('loadedmetadata', () => {
            const duration = document.getElementById('duration');
            if (duration) {
                duration.textContent = this.formatTime(audio.duration);
            }
        });
        
        audio.addEventListener('timeupdate', () => {
            if (!this.appData.activeMusicPlayer) return;
            
            const currentTime = document.getElementById('currentTime');
            const progressFill = document.getElementById('musicProgressFill');
            
            if (currentTime) currentTime.textContent = this.formatTime(audio.currentTime);
            if (progressFill) progressFill.style.width = `${(audio.currentTime / audio.duration) * 100}%`;
            
            this.appData.musicCurrentTime = audio.currentTime;
        });
        
        audio.addEventListener('ended', () => {
            this.handleMusicEnded();
        });
        
        this.appData.musicAudio = audio;
    }

    /**
     * 切换播放/暂停
     */
    toggleMusicPlay() {
        if (!this.appData.musicAudio) return;
        
        const playPauseBtn = document.querySelector('#playPauseMusic i');
        const cd = document.querySelector('#musicCd');
        
        if (this.appData.isMusicPlaying) {
            this.appData.musicAudio.pause();
            playPauseBtn.textContent = 'play_arrow';
            cd.classList.remove('playing');
        } else {
            this.appData.musicAudio.play();
            playPauseBtn.textContent = 'pause';
            cd.classList.add('playing');
        }
        
        this.appData.isMusicPlaying = !this.appData.isMusicPlaying;
    }

    /**
     * 跳转到指定位置
     */
    seekMusic(e) {
        if (!this.appData.musicAudio) return;
        
        const progressBar = document.getElementById('musicProgressBar');
        const rect = progressBar.getBoundingClientRect();
        const percent = (e.clientX - rect.left) / rect.width;
        const seekTime = percent * this.appData.musicAudio.duration;
        
        this.appData.musicAudio.currentTime = seekTime;
    }

    /**
     * 上一首
     */
    playPrevMusic() {
        const musicList = this.appData.musicSettings?.musicList || [];
        if (musicList.length === 0) {
            this.closeMusicPlayer();
            return;
        }
        
        const currentMusic = this.appData.currentPlayingMusic;
        let index = musicList.findIndex(m => m.id === currentMusic?.id);
        
        if (index === -1) index = 0;
        else index = (index - 1 + musicList.length) % musicList.length;
        
        const prevMusic = musicList[index];
        this.openMusicPlayer(prevMusic);
    }

    /**
     * 下一首
     */
    playNextMusic() {
        const musicList = this.appData.musicSettings?.musicList || [];
        if (musicList.length === 0) {
            this.closeMusicPlayer();
            return;
        }
        
        const currentMusic = this.appData.currentPlayingMusic;
        let index = musicList.findIndex(m => m.id === currentMusic?.id);
        
        if (index === -1) index = 0;
        else index = (index + 1) % musicList.length;
        
        const nextMusic = musicList[index];
        this.openMusicPlayer(nextMusic);
    }

    /**
     * 音乐播放结束处理
     */
    handleMusicEnded() {
        const playMode = this.appData.musicSettings?.playMode || 'random';
        
        switch (playMode) {
            case 'single':
                this.appData.musicAudio.currentTime = 0;
                this.appData.musicAudio.play();
                break;
            case 'list':
            case 'random':
                this.playNextMusic();
                break;
            default:
                this.appData.isMusicPlaying = false;
                const playPauseBtn = document.querySelector('#playPauseMusic i');
                const cd = document.querySelector('#musicCd');
                if (playPauseBtn) playPauseBtn.textContent = 'play_arrow';
                if (cd) cd.classList.remove('playing');
                break;
        }
    }

    /**
     * 关闭音乐播放器
     */
    closeMusicPlayer() {
        if (this.appData.musicAudio) {
            this.appData.musicAudio.pause();
            this.appData.musicAudio = null;
        }
        
        if (this.appData.activeMusicPlayer) {
            this.appData.activeMusicPlayer.remove();
            this.appData.activeMusicPlayer = null;
        }
        
        this.appData.isMusicPlaying = false;
        this.appData.currentPlayingMusic = null;
    }

    /**
     * 保存音乐设置
     */
    saveMusicSettings() {
        const autoPlayMusic = document.getElementById('autoPlayMusic');
        const musicFrequencySlider = document.getElementById('musicFrequencySlider');
        const playModeRadios = document.querySelectorAll('input[name="musicPlayMode"]');
        
        if (!this.appData.musicSettings) {
            this.appData.musicSettings = { musicList: [] };
        }
        
        if (autoPlayMusic) {
            this.appData.musicSettings.autoPlayMusic = autoPlayMusic.checked;
        }
        
        if (musicFrequencySlider) {
            this.appData.musicSettings.musicFrequency = parseInt(musicFrequencySlider.value);
        }
        
        playModeRadios.forEach(radio => {
            if (radio.checked) {
                this.appData.musicSettings.playMode = radio.value;
            }
        });
        
        this.saveAllData();
        this.showNotification('音乐设置已保存');
        this.closeSettingsPanel();
    }

    /**
     * 对方主动播放音乐
     */
    simulateMusicPlay() {
        const settings = this.appData.musicSettings;
        if (!settings || !settings.autoPlayMusic) return;
        
        const musicList = settings.musicList || [];
        if (musicList.length === 0) return;
        
        const frequency = settings.musicFrequency || 30;
        if (Math.random() * 100 > frequency) return;
        
        let selectedMusic;
        const playMode = settings.playMode || 'random';
        
        if (playMode === 'random') {
            const randomIndex = Math.floor(Math.random() * musicList.length);
            selectedMusic = musicList[randomIndex];
        } else {
            const lastMusic = this.appData.lastPlayedMusic;
            let index = musicList.findIndex(m => m.id === lastMusic?.id);
            index = (index + 1) % musicList.length;
            selectedMusic = musicList[index];
        }
        
        this.appData.lastPlayedMusic = selectedMusic;
        
        setTimeout(() => {
            this.openMusicPlayer(selectedMusic);
            
            const musicMessage = {
                id: this.dataManager.generateMessageId(),
                type: 'music',
                text: `对方播放了歌曲: ${selectedMusic.name}`,
                sender: 'other',
                time: this.getCurrentTime(),
                read: true
            };
            
            this.appData.messages.push(musicMessage);
            this.renderMessages();
            this.saveAllData();
            
            this.showNotification(`对方正在播放: ${selectedMusic.name}`);
        }, 1000 + Math.random() * 2000);
    }

    /**
     * 格式化时间
     */
    formatTime(seconds) {
        if (isNaN(seconds) || seconds === Infinity || seconds < 0) return '00:00';
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    /**
     * 启动音乐播放定时器
     */
    startMusicScheduler() {
        if (this.appData.musicTimer) {
            clearInterval(this.appData.musicTimer);
        }
        
        const settings = this.appData.musicSettings;
        if (!settings || !settings.autoPlayMusic || settings.musicFrequency <= 0) return;
        
        const baseInterval = 300000; // 5分钟
        const checkInterval = baseInterval * (100 / Math.max(settings.musicFrequency, 10));
        
        this.appData.musicTimer = setInterval(() => {
            this.simulateMusicPlay();
        }, checkInterval);
    }
    
    // ========================
    // 通知
    // ========================
    
    showNotification(message) {
        const existing = document.querySelector('.notification');
        if (existing) existing.remove();
        
        const notification = document.createElement('div');
        notification.className = 'notification';
        notification.textContent = message;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            if (notification.parentNode) notification.remove();
        }, 3000);
    }
}

// ========================
// 启动应用
// ========================
document.addEventListener('DOMContentLoaded', () => {
    window.chatApp = new ChatApp();
});
</script>
</body>
</html>